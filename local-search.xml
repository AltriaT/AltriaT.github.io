<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高精度A+B</title>
    <link href="/2021/11/30/%E9%AB%98%E7%B2%BE%E5%BA%A6A+B/"/>
    <url>/2021/11/30/%E9%AB%98%E7%B2%BE%E5%BA%A6A+B/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度A-B"><a href="#高精度A-B" class="headerlink" title="高精度A+B"></a>高精度A+B</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>c语言int 最大是$2^{31}-1$，64位电脑下long 和long long 最大是 $2^{63}-1$。</p><p>于是我们再进行高精度计算时，如果数值超过$2^{63}-1$就无法存储了。</p><p>我们会想用double来计算，但浮点数是用二进制模拟的，不准确，有误差。</p><p>于是我们需要用一种更高精度的方式来计算高精度A+B。</p><h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><p>在小学，我们都学过加法运算吧。我们的方法就是模拟这个过程来计算，再将计算的数值存入一个无限长的表里。最终输出这个表，就是答案了。</p><p>先来看看小学的方式</p><p>image<img src="/img/%E7%AE%97%E6%B3%95/A+B.png" alt="A+B"></p><p>这个表选择vector作为容器。不会vector看这里<a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析 | 菜鸟教程 (runoob.com)</a></p><p>计算过程就是A的k位加B的k位，将位数的个位存入表，将十位存入t。</p><p>下一次，将A的k位加B的k位+t，将位数的个位存入表，将十位存入t。</p><p>直到，A或B都加到头。（已经到头的就不加入了比如B到头就是 A[k]+t）</p><p>最终，有进位的t就在表里加1，就结束了。</p><p>这就是小学计算加法的过程。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; A,vector&lt;<span class="hljs-keyword">int</span>&gt; B)</span></span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; C;<span class="hljs-comment">//结果</span><br>    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//位数相加的结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>())t+=A[i];<br>         <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>string a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; A,B,C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    C=<span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkList</title>
    <link href="/2021/11/29/LinkList/"/>
    <url>/2021/11/29/LinkList/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表是最简单的链式结构，也是一切的基础。</p><p>先来看看它的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br><span class="hljs-keyword">int</span> data;<span class="hljs-comment">//存的数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个节点的指针</span><br>&#125;LNode,*SqList;<br></code></pre></td></tr></table></figure><p>创建一个单链表有多种方法</p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>有头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FILO_H</span><span class="hljs-params">(SqList &amp;S,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>    S-&gt;next=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>SqList q=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q-&gt;data);<br>        q-&gt;next=S-&gt;next;<br>        S-&gt;next=q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FILO</span><span class="hljs-params">(SqList &amp;S,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>SqList q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(!i)&#123;<br>S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;S-&gt;data);<br>S-&gt;next=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>q=S;<br>S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;S-&gt;data);<br>S-&gt;next=q;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>有头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SqList <span class="hljs-title">FIFO_H</span><span class="hljs-params">(SqList &amp;q)</span></span>&#123;<br>SqList p;<br>p=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;data);<br>p-&gt;next=q-&gt;next;<br>q-&gt;next=p;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>无头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIFO</span><span class="hljs-params">(SqList &amp;S,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>SqList r,q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(!i)&#123;<br>S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;S-&gt;data);<br>            S-&gt;next=<span class="hljs-literal">NULL</span>;<br>            r=S;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        q=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q-&gt;data);<br>        q-&gt;next=r-&gt;next;<br>        r-&gt;next=q;<br>        r=r-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链式结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HushTable</title>
    <link href="/2021/11/26/HushTable/"/>
    <url>/2021/11/26/HushTable/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表是用来做什么的？"><a href="#哈希表是用来做什么的？" class="headerlink" title="哈希表是用来做什么的？"></a>哈希表是用来做什么的？</h2><p>​    以平均常数时间对关键字进行查找、删除、插入。</p><p>​    hash表是为了以最快的时间查找到内容，同时保证空间利用的高效，可以说是和珅最爱了。</p><p>​    就好比一个3个字母的英语单词我们可以把它看成一个三维空间的点，然后我们把他表示成一个数的方式是从（0，0，0）标记成0，（25,25,25）标记成$26\times 26\times 26$。然后中间的某一单词就是$26^2 \times x+26\times y+z $，对于更长的单词是更高次幂的多项式表示。</p><p>这种方式查找是快了，但对空间的浪费很大。常用的单词并没有这么多。</p><p>哈希通过散列函数将关键字<strong>x</strong> (可以是任意值)映射为<strong>y</strong> (某一地址)。好的散列函数既要保证空间利用的高效，又要照顾查找的快慢。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="如何选择散列函数"><a href="#如何选择散列函数" class="headerlink" title="如何选择散列函数"></a>如何选择散列函数</h3><ol><li>直接地址法：H(key)=key, H(key)=$a \times key+b$</li><li>除留余数法：H(key)=key%p</li><li>数字分析法：找数字段中在散列表中可以分布均匀的的地方</li><li>平方取中法：取平方值的中间几位作为散列地址</li></ol><p>我们主要讨论除留取余法。</p><p>​    字符串处理方法：</p><ol><li><p>$\sum_{i=0}^nASCII(key[i])\mod p$</p></li><li><p>将字符串长度看成维度扁平化为一维数字，然后将扁平化后的数字mod p</p><p>扁平化就像<em>哈希表是用来做什么的？</em>里面所说的那样。</p></li><li><p>将2.的扁平化用秦九韶算法优化，将乘法变为左移提高速度。</p></li></ol><h3 id="哈希函数产生的冲突"><a href="#哈希函数产生的冲突" class="headerlink" title="哈希函数产生的冲突"></a>哈希函数产生的冲突</h3><p>​    不同数字之间的余数可能会相同，不同字符串的字符值求和也可能相同，种种原因等导致最后哈希函数计算出的哈希地址相同，这种情况称为冲突。</p><p>冲突是哈希函数尽量避免而又避免不了的，那么我们又将如何处理和减少冲突呢。</p><ol><li><p>选择合适的素数为哈希表大小，减少冲突</p></li><li><p>用合适的方法处理，处理冲突</p><ol><li><p>分离链式法：将重复的值在同一单链表中。</p><p>优点：表长短，省空间。</p><p>缺点：查找时时间会随着链表长度加长而加长。</p></li><li><p>开放地址法：</p><p>$h_i(key)=(Hash(key)+F(i)) \mod p $</p><p>冲突后就将地址用F（i）偏移到其他地方，i 代表偏移次数。</p><p>以下是常用的偏移方法</p><p>方法一：线性探测法</p><p>​    F(i)=i</p><p>​    优点：操作简单</p><p>​    缺点：这样容易形成一次聚集区块，导致查找时间变长。</p><p>改进：$F(i)=(-1)^i \times i $</p><p>方法二：平方探测法（二次探测）</p><p>​    $F(i)=(-1)^{i}\times i^2$，k&lt;=m/2，散列表长度m必须是一个可以表示成$4\times k+3$的素数，称为二次探测法。</p><p>​    避免了堆积，但不能用上所有单元，但至少能探测到一半单元。</p><p>​    优点：一定程度上避免了聚集</p><p>​    缺点：表的空间利用率不高</p><p>方法三：再散列</p><p>再散列有普通版和优化版。</p><ol><li>普通版就是当第一个hash函数冲突时用第二个hash函数，第二个冲突用第三个hash函数，直到地址不冲突为止。</li></ol><p>​    经过表长次回到原点</p><p>​    普通版解决冲突问题的能力是有限的，一旦表很满时（填充因子就很大），找不冲突就很难，再散列的次数就越多。</p><ol start="2"><li><p>优化版当元素太满时，找一个新空间，表长是上一次表长2倍后的第一个素数。将原表插入到新表。</p><p>优点：聚集减少了，也不用担心表长不够</p><p>缺点：建立新表费时间</p></li></ol></li></ol><h2 id="分离链式法"><a href="#分离链式法" class="headerlink" title="分离链式法"></a>分离链式法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_SIZE=<span class="hljs-number">1001</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span>&#123;</span><br><span class="hljs-keyword">int</span> data;<br><span class="hljs-keyword">bool</span> flag;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;HNode,*Node;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>HNode eles[MAX_SIZE];<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">int</span> MAX_NUM;<br>&#125;HushTable;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitHushTable</span><span class="hljs-params">(HushTable &amp;H,<span class="hljs-keyword">int</span> m)</span></span>&#123;<br>H.MAX_NUM=m;<br>H.num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;H.MAX_NUM;i++) H.eles[i].flag=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;H.MAX_NUM;i++) H.eles[i].next=<span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(HushTable &amp;H,<span class="hljs-keyword">int</span> ele)</span></span>&#123;<br><span class="hljs-comment">//头插法 </span><br>HNode *q=(Node)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(HNode));<br>q-&gt;data=ele;<br>q-&gt;flag=<span class="hljs-literal">true</span>;<br>q-&gt;next=H.eles[ele%(H.MAX_NUM)].next;<br><span class="hljs-comment">//取模插入 </span><br>H.eles[ele%(H.MAX_NUM)].next=q;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-keyword">int</span> *eles;<br><span class="hljs-keyword">bool</span> *flag;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">int</span> TableSize;<br>&#125;hushtable;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateHushTable</span><span class="hljs-params">(hushtable &amp;H)</span></span>&#123;<br>H.eles=(<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">53</span>);<br>H.flag=(<span class="hljs-keyword">bool</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">bool</span>)*<span class="hljs-number">53</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">53</span>;i++)H.flag[i]=<span class="hljs-literal">false</span>;<br>H.num=<span class="hljs-number">0</span>;<br>H.TableSize=<span class="hljs-number">53</span>;<br>&#125;<br><span class="hljs-comment">//我写的版</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hush</span><span class="hljs-params">(hushtable &amp;H,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;H.TableSize;i++)&#123;<br><span class="hljs-keyword">if</span>(!H.flag[(x+i)%H.TableSize])<span class="hljs-keyword">return</span> (x+i)%H.TableSize;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//AcWing版</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(hushtable &amp;H,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> N=H.TableSize;<br>    <span class="hljs-keyword">int</span> t=(x%N+N)%N;<br>    <span class="hljs-keyword">while</span>(!(!H.flag[t]||H.eles[t]==x))&#123;<br>        t=(t+<span class="hljs-number">1</span>)%N;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add</span><span class="hljs-params">(hushtable &amp;H,<span class="hljs-keyword">int</span> ele)</span></span>&#123;<br><span class="hljs-keyword">if</span>(H.TableSize==H.num)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">int</span> t=<span class="hljs-built_in">hush</span>(H,ele);<br>H.eles[t]=ele;<br>H.flag[t]=<span class="hljs-literal">true</span>;<br>H.num++;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>AcWing 的时间更少，我的在测试时会有样例超时。</p><h2 id="平方探测"><a href="#平方探测" class="headerlink" title="平方探测"></a>平方探测</h2><p>和线性探测一样，就是换个函数。</p><h3 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h3><p>我们这里直接使用优化版再散列函数。</p><p>衡量是否太满的值是填装因子，可以自己调节。</p><p>插入时可用线性或平方探测。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Rehush</span><span class="hljs-params">(hushtable &amp;H,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br> <span class="hljs-keyword">int</span> N=H.TableSize;<br> <span class="hljs-keyword">double</span> a=(H.num*<span class="hljs-number">1.0</span>)/H.TableSize;<br> <span class="hljs-comment">//填装因子判定 </span><br> <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0.5</span>)&#123;<br> <span class="hljs-keyword">int</span> new_TableSize=<span class="hljs-built_in">Find_Prime_Number</span>(H.TableSize);<br> hushtable newH;<br> <span class="hljs-built_in">InitHushTable</span>(newH,new_TableSize);<br> <span class="hljs-comment">//导入新空间 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;H.TableSize;i++)&#123;<br><span class="hljs-keyword">if</span>(H.flag[i])<span class="hljs-built_in">Insert</span>(newH,H.eles[i]);<br>&#125;<br><span class="hljs-comment">//释放就的空间，将新的copy到旧的名字。 </span><br><span class="hljs-built_in">free</span>(H.eles);<br><span class="hljs-built_in">free</span>(H.flag);<br>H.eles=newH.eles;<br>H.flag=newH.flag;<br>H.num=newH.num;<br>H.TableSize=newH.TableSize;<br> &#125;<br> <span class="hljs-built_in">Insert</span>(H,x);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>graph2</title>
    <link href="/2021/11/25/graph2/"/>
    <url>/2021/11/25/graph2/</url>
    
    <content type="html"><![CDATA[<h1 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h1><h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>​    生成树：一个连通图的生成树是一个极小的连通子图，它包含图中全部的n个顶点，但只有构成一棵    树的n-1条边。</p><p>​    最小生成树：就是原图中<strong>边的权值的和最小的生成树</strong> ，所谓最小是指边的权值之和小于或者等于其它生成树的边的权值之和。</p><ol><li><p><strong>prim</strong></p><p>Prim算法针对的是连通网（连通带权图）的最小生成树。每次都要从不在集合中选这一个距离集合最近的点，直到所有节点都被选入集合。</p><p><em><strong>*这里面最特殊的就是被选入的第一个点，初始的距离都是无穷，所以随便选取一个点就可以，而t==-1这个判断条件使得0号元素可以选中，也就固定的每次从数组0号开始生成最小生成树*</strong></em></p><p>邻接矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(MGraph &amp;G,ALGraph &amp;Tree)</span></span>&#123;<span class="hljs-comment">//树可以是个图，他是无向有权图</span><br>Tree.vexnum=G.vexnum;<br>Tree.arcnum=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//dist是一个用来表示该点到集合内任一点中最小的距离 </span><br><span class="hljs-keyword">int</span> dist[MAX_VERTEX_NUM];<br><span class="hljs-comment">//初始化为无穷</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAX_VERTEX_NUM;i++)dist[i]=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-comment">//flag在这里表示是否进入集合</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++) G.flag[i]=<span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//开始生成树 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-comment">//一个指针，指向距离集合最小点的下标。</span><br><span class="hljs-keyword">int</span> t=<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//找到路径最小的点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;j++)&#123;<br><span class="hljs-keyword">if</span>(!G.flag[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))t=j;<br>&#125;<br>G.flag[t]=<span class="hljs-literal">true</span>;<br><span class="hljs-comment">//第i个点不是第一个（后面没更新），其余如果最小距离集合的点是无穷大，就说明网不连通 </span><br><span class="hljs-keyword">if</span>(i&amp;&amp;dist[t]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//建树</span><br><span class="hljs-keyword">if</span>(i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++)&#123;<br><span class="hljs-comment">//如果k-&gt;t是这条最短边，就将这两个点在树里链接</span><br><span class="hljs-keyword">if</span>(G.arcs[k][t].adj==dist[t])&#123;<br><span class="hljs-built_in">add</span>(Tree,k,t,G.vexs[k],G.vexs[t],dist[t]);<br>&#125;<br>&#125;<br><span class="hljs-comment">//更新，用最小那个点来更新最短距集合的距离。 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;j++)dist[j]=<span class="hljs-built_in">Min</span>(dist[j],G.arcs[t][j].adj);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>树是包含于图的，它是一个无向图，可以用邻接表的方式表示，创建树也是会创建无向图的过程</p></li><li><p><strong>Kruskal</strong></p><p>​    Kruskal针对连通无向有权图求最小生成树，先对边进行排序，每次选择最小的边，看两个点是否为一个集合内，如果是就不连接，不是就将这条边连接。</p><p>AcWing 版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> p[<span class="hljs-number">100010</span>];<br><span class="hljs-comment">//结构体是边</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edg</span>&#123;</span><br>    <span class="hljs-comment">//a,b是边连接的两个点，w是权重</span><br>    <span class="hljs-keyword">int</span> a,b,w;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> edg &amp;W)<span class="hljs-keyword">const</span>&#123;<span class="hljs-comment">//重载小于号</span><br>        <span class="hljs-keyword">return</span> w&lt;W.w;<br>    &#125;<br>&#125;edgs[<span class="hljs-number">200010</span>];<br><span class="hljs-comment">//并查集查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x!=p[x])p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a,b,w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);<br>        edgs[i].a=a;<br>        edgs[i].b=b;<br>        edgs[i].w=w;<br>        <span class="hljs-comment">//edgs[i]=&#123;a,b,w&#125;;</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(edgs,edgs+m);<span class="hljs-comment">//重载是为了比较的时候&lt;号直接比较的是结构体中的w.</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)p[i]=i;<span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a=edgs[i].a,b=edgs[i].b,w=edgs[i].w;<span class="hljs-comment">//权重为w</span><br>        a=<span class="hljs-built_in">find</span>(a),b=<span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            p[a]=b;<br>            res+=edgs[i].w;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt&lt;n<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);<span class="hljs-comment">//一共选n-1条边就是生成树，小于就不连通</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ol><li><p><strong>Dijkstra</strong></p><p>和prim最小生成树极为相似，区别在于更新时，这里是点1到点j的最短路,而prim是集合到点j的最短</p><p>每一个较短路都是通过以确定的最短路加上终点到对应点的距离比较得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-comment">//n是点数，m是边数</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-comment">//g是邻接矩阵，dist是到1点的最短距离，st是是否确定最短路的状态</span><br><span class="hljs-keyword">int</span> g[N][N],dist[N],st[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dist));<span class="hljs-comment">//int 站四个字节，四个字节都是3f，作为无穷大</span><br>    <span class="hljs-comment">//初始化，1到1的距离是0</span><br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//t记录最短路的终点</span><br>        <span class="hljs-keyword">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//找出最短的终点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))&#123;<br>                t=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将他的最短状态确定</span><br>        st[t]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//有这条最短更新其他结点最短路</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这个题是让返回1到n的最短路</span><br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//3f3f3f3f才是int最大</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>Dijkstra还可以用堆优化</p></li><li><p><strong>Floyd</strong></p><p>本质是用动态规划求解最短路</p><p>由前面可达的点的最短路得到该点最短路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> d[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br><span class="hljs-keyword">int</span> n,m,k;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[k][j]+d[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)d[i][i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//自己到自己最短是0，题里有自环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a,b,w;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>        d[a][b]=<span class="hljs-built_in">min</span>(w,d[a][b]);<span class="hljs-comment">//题里有重边</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(d[a][b]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//题里有负权边</span><br>        <span class="hljs-keyword">else</span> cout&lt;&lt;d[a][b]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序针对的是AOV网，他必须有向，有权值，无环</p><p>排列出工作完成的先后合理顺序</p><p>思想基础是bfs</p><p>最后这个队列中装上所有的结点就证明无环。若是有环就一定有节点入读无法减为零。这个刻意判定环的存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拓扑排序（邻接表） </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TopSort</span><span class="hljs-params">(ALGraph &amp;G,<span class="hljs-keyword">int</span> **ans)</span></span>&#123;<br><span class="hljs-comment">//初始化标志 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++) G.vertices[k].flag=<span class="hljs-literal">false</span>;<br><span class="hljs-comment">//以bfs为基础框架 </span><br>queue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-comment">//先遍历一遍所有节点，将所有入度为0的点装入队列中</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.vertices[i].in_degree==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">push</span>(Q,i);<br>G.vertices[i].flag=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//队列不为空，就出度。 </span><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-comment">//遍历出度所连接的点，将其入度减一。</span><br><span class="hljs-keyword">for</span>(ArcNode *q=G.vertices[e].firstarc;q;q=q-&gt;nextarc)&#123;<br><span class="hljs-keyword">int</span> j=q-&gt;adjvex;<br><span class="hljs-keyword">if</span>(G.vertices[j].flag)<span class="hljs-keyword">continue</span>;<br>G.vertices[j].in_degree--;<br><span class="hljs-comment">//入度为空入队列 </span><br><span class="hljs-keyword">if</span>(G.vertices[j].in_degree==<span class="hljs-number">0</span>)&#123;<br> G.vertices[j].flag=<span class="hljs-literal">true</span>;<br><span class="hljs-built_in">push</span>(Q,j);<br>&#125; <br>&#125;<br>&#125;<br>*ans=Q.ele;<br><span class="hljs-keyword">return</span> Q.r==G.vexnum;<span class="hljs-comment">//队列中的记录过结点总数个点说明它遍历完了，没有环。否则，有环。 </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拓扑排序（邻接矩阵） </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TopSort</span><span class="hljs-params">(MGraph &amp;G,<span class="hljs-keyword">int</span> **ans)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++) G.flag[i]=<span class="hljs-literal">false</span>;<br><br>queue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.in_degree[i]==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">push</span>(Q,i);<br>G.flag[i]=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.flag[i])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(G.arcs[e][i].adj==<span class="hljs-number">1</span>)&#123;<br>G.in_degree[i]--;<br><span class="hljs-keyword">if</span>(G.in_degree[i]==<span class="hljs-number">0</span>)&#123;<br>G.flag[i]=<span class="hljs-literal">true</span>;<br><span class="hljs-built_in">push</span>(Q,i);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>*ans=Q.ele;<br><span class="hljs-keyword">return</span> Q.r==G.vexnum;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p><em><strong>*关键路径的关键之处是要保证在整个任务完成的前提下进行。*</strong></em></p><p><em><strong>*里面所说的最大和最小都是在所有前提事件、活动都可以完成的情况下来讨论的，活动可以并发进行（多线程）*</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CriticalPath</span><span class="hljs-params">(MGraph &amp;G)</span></span>&#123;<span class="hljs-comment">//要保证在任务可完成的前提下 </span><br><span class="hljs-comment">//vl事件发生的最晚时间，ve事件发生的最早时间 </span><br><span class="hljs-keyword">int</span> vl[G.vexnum],ve[G.vexnum];<br><span class="hljs-comment">//求最小寻最大，初始化为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)ve[i]=<span class="hljs-number">0</span>; <br><span class="hljs-comment">//求最大寻最小，初始化为无穷大</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)vl[i]=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">//拓扑排序（邻接矩阵） 求事件最早</span><br><span class="hljs-comment">//初始化标志 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++) G.flag[i]=<span class="hljs-literal">false</span>;<br>queue Q;<br>stack S;<span class="hljs-comment">//拓扑排序的逆序</span><br><span class="hljs-built_in">InitStack</span>(S);<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-comment">//先遍历一遍所有节点，将所有入度为0的点装入队列中</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.in_degree[i]==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">push</span>(Q,i);<br><span class="hljs-built_in">PUSH</span>(S,i);<br>G.flag[i]=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//队列不为空，就出度。</span><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-comment">//遍历出度所连接的点，将其入度减一。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.flag[i])<span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//时间不是无穷说明有边 </span><br><span class="hljs-keyword">if</span>(G.arcs[e][i].adj!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br>G.in_degree[i]--;<br><span class="hljs-comment">//将事件的较早开始时间计算出来</span><br>ve[i]=<span class="hljs-built_in">Max</span>(ve[i],ve[e]+G.arcs[e][i].adj);<span class="hljs-comment">//</span><br><span class="hljs-comment">//入度为空入队列 </span><br><span class="hljs-keyword">if</span>(G.in_degree[i]==<span class="hljs-number">0</span>)&#123;<br>G.flag[i]=<span class="hljs-literal">true</span>;<br><span class="hljs-built_in">push</span>(Q,i);<br><span class="hljs-built_in">PUSH</span>(S,i);<span class="hljs-comment">//逆序 </span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//逆拓扑排序，入度信息已丢失,用栈来代替 求事件最晚 </span><br><span class="hljs-comment">//栈顶是最后一个事件 </span><br><span class="hljs-keyword">int</span> top=<span class="hljs-built_in">GetTop</span>(S);<br><span class="hljs-comment">//他的最早就是最晚 </span><br>vl[top]=ve[top]; <br><span class="hljs-comment">//栈不空出栈 </span><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(S))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">POP</span>(S,e);<br><span class="hljs-comment">//将所有和当前点有边的点计算较晚的值 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><br><span class="hljs-keyword">if</span>(G.arcs[i][e].adj!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br>vl[i]=<span class="hljs-built_in">Min</span>(vl[i],vl[e]-G.arcs[i][e].adj);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br> <span class="hljs-comment">/*这里的边是用两个点（数）表示的，而活动的早晚信息使用一个数表示活动，要将二维映射成一维，建立一一对应的关系。边的最大数值是点数的两两组合数。*/</span><br><span class="hljs-comment">//求活动开始与结束的最早和最晚</span><br><span class="hljs-keyword">int</span> e[MAX_ARC_NUM],l[MAX_ARC_NUM];<span class="hljs-comment">//MAX_ARC_NUM是C_(n-1)&#123;2&#125;算出来的 </span><br><span class="hljs-comment">//不可能是相同负值所以初始化为不同负值 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAX_ARC_NUM;i++)e[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAX_ARC_NUM;i++)l[i]=<span class="hljs-number">-2</span>;<br><span class="hljs-comment">//由点到边要对应(i*10+j)(i*4+j)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;j++)&#123;<br><span class="hljs-keyword">if</span>(G.arcs[i][j].adj!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br><span class="hljs-comment">//二位坐标映射为一维坐标 </span><br><span class="hljs-keyword">int</span> k=i*<span class="hljs-number">4</span>+j;<br>e[k]=ve[i];<br>l[k]=vl[j]-G.arcs[i][j].adj;<br><span class="hljs-comment">//最早和最晚相同就说明不能拖延,是关键路径上的边 </span><br><span class="hljs-keyword">if</span>(e[k]==l[k])<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d--%d &quot;</span>,G.vexs[i],G.vexs[j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>image<img src="/img/graph/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.jpg" alt="关键路径"></p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>graph</title>
    <link href="/2021/11/22/graph/"/>
    <url>/2021/11/22/graph/</url>
    
    <content type="html"><![CDATA[<h1 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h1><pre><code class=" mermaid">graph LR图--&gt;图的定义图--&gt;图的存储结构--&gt;邻接表--&gt;稀疏图图的存储结构--&gt;邻接矩阵--&gt;稠密图图的存储结构--&gt;十字链表图--&gt;图的遍历图的遍历--&gt;深度优先遍历dfs图的遍历--&gt;广度优先遍历bfs图--&gt;图的应用图的应用--&gt;最小生成树--&gt;prim最小生成树--&gt;Kruskal图的应用--&gt;最短路径最短路径--&gt;Dijkstra最短路径--&gt;Floyd图的应用--&gt;拓扑排序--&gt;逆拓扑排序图的应用--&gt;关键路径</code></pre><h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><p>图是由顶点的有穷非空集合和顶点之间边的集合组成， 通常表示为: G（V，E）， 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。$|V|$表示点的个数，$|E|$表示边的个数。</p><p>注意：树可以是空树，线性表可以是空表，图不可以为空图。</p><p>图的种类：(无向图、有向图、无向网、有向网)，(简单图，多重图)，(完全图)，(子图)，(稠密图、稀疏图)。</p><p>##图的存储结构</p><ol><li><p>邻接表：用来存稀疏图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MaxVerNum=<span class="hljs-number">100</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>&#123;</span><br>    <span class="hljs-comment">//弧指向顶点的位置</span><br><span class="hljs-keyword">int</span> adjvex;<br>    <span class="hljs-comment">//指向下一个弧的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">//弧的信息，例如权值</span><br>    <span class="hljs-comment">//InfoType info;</span><br>&#125;ArcNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span>&#123;</span><br>    <span class="hljs-comment">//顶点信息</span><br>    VertexType data;<br>    <span class="hljs-comment">//第一个弧</span><br>    ArcNode *firstarc;<br>&#125;VNode,AdjList[MaxVerNum];<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-comment">//邻接表(结点数组)</span><br>    AdjList vertices;<br>    <span class="hljs-keyword">int</span> vexnum,arcnum;<br>&#125;ALGraph;<br></code></pre></td></tr></table></figure></li><li><p>邻接矩阵：用来存稠密图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcCell</span>&#123;</span><br>    <span class="hljs-keyword">int</span> adj;<br>    <span class="hljs-comment">//节点其他信息</span><br>    <span class="hljs-comment">//InfoType *info;</span><br>&#125;ArcCell,AdjMatrix[MaxVerNum][MaxVerNum];<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-keyword">int</span> vexs[MaxVerNum];<br>    AdjMatrix arcs;<br>    <span class="hljs-keyword">int</span> vexnum,arcnum;<br>    <span class="hljs-comment">//int in_degree[MaxVerNum];</span><br>    <span class="hljs-comment">//bool flag[MaxVerNum];</span><br>&#125;ALGraph;<br></code></pre></td></tr></table></figure><p>创建无向边，就是创建有向边正反两遍。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>与树的层序遍历相似，用到了队列。</p><ol><li><p>从某一v结点开始访问</p></li><li><p>记录v的所有相邻节点</p></li><li><p>只要没访问过，从相邻结点队列中出一个从1开始。</p></li><li><p>直到图中点都被访问</p><p><em><strong>*类似于树的bfs遍历，区别是有重复，所以要flag标记。*</strong></em></p><p>邻接表的bfs：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(ALGraph &amp;G,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//初始化标志信息 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++) G.vertices[k].flag=<span class="hljs-literal">false</span>;<br><span class="hljs-comment">//用到了队列 </span><br>queue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-built_in">push</span>(Q,i);<br><span class="hljs-comment">//做标记 </span><br>G.vertices[i].flag=<span class="hljs-literal">true</span>;<br><span class="hljs-comment">//队不空出队 访问 </span><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,G.vertices[e].data);<br><span class="hljs-comment">//将出队元素的相邻元素入队</span><br><span class="hljs-keyword">for</span>(ArcNode *q=G.vertices[e].firstarc;q;q=q-&gt;nextarc)&#123;<br><span class="hljs-keyword">if</span>(G.vertices[q-&gt;adjvex].flag)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">push</span>(Q,q-&gt;adjvex);<br>G.vertices[q-&gt;adjvex].flag=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>邻接矩阵bfs：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(MGraph &amp;G,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++) G.flag[k]=<span class="hljs-number">0</span>;<br>queue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-built_in">push</span>(Q,i);<br>G.flag[i]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,G.vexs[e]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++)&#123;<br><span class="hljs-keyword">if</span>(G.flag[k])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(G.arcs[e][k].adj!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<span class="hljs-comment">//无穷代表不连接</span><br><span class="hljs-built_in">push</span>(Q,k);<br>G.flag[k]=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><ol><li>从某一结点v开始访问</li><li>访问v的某一相邻结点（没被访问过）</li><li>重复，直到不能再访问</li></ol><p><em><strong>*类似于树的dfs遍历，区别是有重复，所以要flag标记。*</strong></em></p><p>邻接表的dfs (递归)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ALGraph &amp;G,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//出口：该节点已被访问过。 </span><br><span class="hljs-keyword">if</span>(G.vertices[i].flag)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//访问结点 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,G.vertices[i].data);<br><span class="hljs-comment">//标记已访问 </span><br>G.vertices[i].flag=<span class="hljs-literal">true</span>;<br><span class="hljs-comment">//遍历当前结点的所有相邻的结点依次dfs遍历 </span><br><span class="hljs-keyword">for</span>(ArcNode *q=G.vertices[i].firstarc;q;q=q-&gt;nextarc)&#123;<br><span class="hljs-built_in">dfs</span>(G,q-&gt;adjvex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>邻接矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(MGraph &amp;G,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">if</span>(G.flag[i])<span class="hljs-keyword">return</span>; <span class="hljs-comment">//exit</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,G.vexs[i]);<br>G.flag[i]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++)&#123;<br><span class="hljs-keyword">if</span>(G.arcs[i][k].adj!=<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-built_in">dfs</span>(G,k);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的特征"><a href="#图的特征" class="headerlink" title="图的特征"></a>图的特征</h2><ol><li>$TD(v)=ID(v)+OD(v)$</li><li>$\sum_{i=1}^n TD(v_i)=2*e$ ,TD是vi的度</li><li>$ID(v)=OD(v)=e$</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HuffmanTree</title>
    <link href="/2021/10/31/HuffmanTree/"/>
    <url>/2021/10/31/HuffmanTree/</url>
    
    <content type="html"><![CDATA[<h1 id="HuffmanTree"><a href="#HuffmanTree" class="headerlink" title="HuffmanTree"></a>HuffmanTree</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有n个学生去考试，分数分为ABCDF四个等级，当我们用程序去分类时，分类代码是这样写的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">seperate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span></span>&#123;<br><span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">90</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">80</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">70</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">60</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;F&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是万金油的方法，但如果我的学生都不及格（开个玩笑），一共要进行n*4次判断才可以完成。</p><p>于是代码写成这样才是最优</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">seperate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span></span>&#123;<br><span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">60</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;F&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">70</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">80</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">90</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样我的学生都考满分，这又是效率最差的方法。</p><p>为了追求效率我们不能将问题细分到每一种情况去考虑。</p><p>那么有没有一种可以使得所有情况都较为高效的方法来解决这种分类问题呢，将这些数据进行一个压缩。</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>首先要知道的是我们要让数量最多的类别进行最少次数的判断。这种思想类似于概率论，种类的数量比作频率p，种类的判断次数比作变量x，我们要做的就是使均值($\sum_{i=1}^{n}{x_i*p_i}$)达到最小。</p><p>而且我们还要保证这些编码互相不能成为前缀，也就是译码（解压）时不可以出现歧义。</p><p>那么找一种什么结构来存呢，我们会想到的是用二叉树来存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-keyword">int</span> weight;<br><span class="hljs-keyword">int</span> lchild,rchild,parent;<br>&#125;*HuffmanTree,HTNode;<br></code></pre></td></tr></table></figure><p>离散数学里学过树是可以有权重的。那么这个权重就可以表示数量等一些信息的重要性。越重要的信息编码量就越小，这样就可以保证最后的信息总量被压缩。</p><p>其编码就是用二叉树的左边和右边来区分（这样就形成了一颗tire树），信息放在叶子节点，从根到叶子的路径就是他的编码。</p><p>我们要做的就是将权值大的信息放离树根近的地方。</p><p>image<img src="/img/tree/5.png" alt="哈夫曼树"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> **HuffmanCode; <br></code></pre></td></tr></table></figure><p><strong>编写哈夫曼树代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HuffmanCoding</span><span class="hljs-params">(HuffmanTree &amp;HT,HuffmanCode &amp;HC,<span class="hljs-keyword">int</span> *w,<span class="hljs-keyword">int</span> n)</span></span>&#123; <br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//计算节点总数</span><br><span class="hljs-keyword">int</span> m=n*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br><span class="hljs-comment">//初始化哈夫曼树</span><br>HT = (HuffmanTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HTNode)*(m+<span class="hljs-number">1</span>));<span class="hljs-comment">//严奶奶不喜欢用第0个 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//方便我自己写的，所以改了一下 </span><br>flag[i]=<span class="hljs-literal">true</span>;<br>HT[i].parent=<span class="hljs-number">0</span>;<br>HT[i].lchild=<span class="hljs-number">0</span>;<br>HT[i].rchild=<span class="hljs-number">0</span>;<br>&#125;<br>HT-&gt;n=n;<br><span class="hljs-comment">//工作指针</span><br>HuffmanTree p;<br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">for</span>(p=HT,i=<span class="hljs-number">1</span>;i&lt;=n;i++)p[i].weight=w[i];<br><span class="hljs-keyword">for</span>(;i&lt;=m;++i)p[i].weight=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=n+<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">int</span> s1,s2;<br>Select(HT,i<span class="hljs-number">-1</span>,s1,s2);<br>HT[s1].parent=i;<br>HT[s2].parent=i;<br>HT[i].lchild=s1;<br>HT[i].rchild=s2;<br>HT[i].weight=HT[s1].weight+HT[s2].weight;<br>&#125;<br><br><span class="hljs-comment">//编码 </span><br>HC = (HuffmanCode)<span class="hljs-built_in">malloc</span>((n+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>*));<br><span class="hljs-keyword">char</span>* cd = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br>cd[n<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//经计算最大n-1个 ：注1</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> start = n<span class="hljs-number">-1</span>;<span class="hljs-comment">//严奶奶倒着存的 ：注2</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c=i,f=HT[i].parent;f!=<span class="hljs-number">0</span>;c=f,f=HT[f].parent)&#123;<br><span class="hljs-keyword">if</span>(HT[f].lchild==c)cd[--start]=<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">else</span> cd[--start]=<span class="hljs-string">&#x27;1&#x27;</span>;<br>&#125;<br>HC[i] = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>((n-start)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br><span class="hljs-built_in">strcpy</span>(HC[i],&amp;cd[start]);<span class="hljs-comment">//严奶奶截取的刚刚好 ：注2</span><br>&#125;<br><span class="hljs-built_in">free</span>(cd);<br>&#125;<br></code></pre></td></tr></table></figure><p>注1：n-1是最大的编码长度，树长成这样：image<img src="/img/tree/7.png"></p><p>注2：从n-1开始存储，下一个是n-2，最后一个的位置就是 strat。</p><p><strong>选择函数代码</strong></p><p>严奶奶书上写的方法就是最好的理解的，这里是书上的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HuffmanTree &amp;HT,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> &amp;s1,<span class="hljs-keyword">int</span> &amp;s2)</span></span>&#123;<br>HT[<span class="hljs-number">0</span>].weight=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">32</span><span class="hljs-number">-1</span>; <br>s1=<span class="hljs-number">0</span>;<br>s2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(HT[s1].weight!=<span class="hljs-number">0</span>&amp;&amp;flag[i]&amp;&amp;HT[s1].weight&gt;HT[i].weight)s1=i;<br>&#125;<br>flag[s1]=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(HT[s2].weight!=<span class="hljs-number">0</span>&amp;&amp;flag[i]&amp;&amp;HT[s2].weight&gt;HT[i].weight)s2=i;<br>&#125;<br>flag[s2]=<span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以用<strong>堆</strong>优化，但要注意不光要照顾权重还要照顾深度。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>threaded binary tree</title>
    <link href="/2021/10/31/threaded-binary-tree/"/>
    <url>/2021/10/31/threaded-binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Threaded-Binary-Tree"><a href="#Threaded-Binary-Tree" class="headerlink" title="Threaded Binary Tree"></a>Threaded Binary Tree</h1><p>线索二叉树实际上是对二叉树的一种优化，利用二叉树中的空链域(n+1个)来存储前驱或后继。</p><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>image<img src="/img/tree/3.jpg" alt="存储结构"></p><p>0代表不空，1代表空</p><p>如果左边空就将lchild链接前驱，如果右边空就将rchild链接后继。</p><h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><p>先序线索二叉树</p><p>中序线索二叉树</p><p>后续线索二叉树</p><p>如图以后续线索二叉树为例</p><p>image<img src="/img/tree/4.png" alt="后继"></p><h2 id="mend"><a href="#mend" class="headerlink" title="mend"></a>mend</h2><p>后续二叉树并不完善，无法做到全部查找后继，需要栈的辅助</p><p>原因：</p><p>​    后续线索二叉树是左右根</p><p>​    如图根节点可能没有空余的指针，所以根节点可能找不到后继，因此需要栈来记录父节点。</p><p>​    image<img src="/img/tree/4.png" alt="后继"></p><p>同理先序二叉树也不完善，无法查找全部前驱。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binary tree</title>
    <link href="/2021/10/22/binary-tree/"/>
    <url>/2021/10/22/binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Binary-tree"><a href="#Binary-tree" class="headerlink" title="Binary tree"></a>Binary tree</h1><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>​    二叉树是另一种树形结构，其特点是每个结点至多有两棵子树（即二叉树中不存在度大于二节点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>​    二叉树也是递归定义。二叉树是n(n&gt;=0)个结点的有限集合：</p><ol><li><p>或者为空二叉树，即n=0。</p></li><li><p>或者为一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树有分别是一棵二叉树。</p><p>二叉树是有序树，若其左右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分他是左子树还是右子树。二叉树的5种基本状态就看书吧。</p></li></ol><p>二叉树与度为2的有序树的区别：</p><p>​    1.度为2的树至少有3个结点，而二叉树可以为空。</p><p>​    2.度为2的有序树的孩子的左右次序是相当于另一孩子而言，若某个结点只有一个孩子，则这个孩子就无需区分其左右次序，而二叉树无论其左右孩子是否为2，均为确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而确定的。</p><h2 id="Special-binary-tree"><a href="#Special-binary-tree" class="headerlink" title="Special binary tree"></a>Special binary tree</h2><p>​    1.满二叉树：高为h，且含有$2^{h}-1$的结点的二叉树称为满二叉树，即树中每层都含有最多节点。可用序号表述，若双亲结点为$i/2$,则有左右孩子时，左孩子为$2<em>i$,右孩子为$2</em>i+1$。</p><p>​    2.完全二叉树：就是将要成为满二叉树，最后一层可能与满二叉树不同的树。</p><p>​        1）若$i&lt;\lfloor n/2 \rfloor$,他就是分支节点。</p><p>​        2）若有度为一的结点，则只有一个，且只有左孩子。</p><p>​        3）一旦出现度为1的结点，它后面全是叶子节点。</p><p>​        4）n为奇数，则每个分支都有左右孩子，若n为偶数，则序号的最大分支结点<strong>（编号为$n/2$）</strong>只有左孩子，其余没得左右孩子。</p><p>​    3.  二叉排序树：左子树上的结点均小于根节点的关键字。右子树上所有节点的关键字都大于根节点的关键字。左子树和右子树又是二叉排序树。</p><p>​    4.平衡二叉树：树上任意节点的左子树和右子树的深度只差不超过1。</p><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><ol><li>非空二叉树上的叶子结点数等于度为2的节点数加1，即n0=n2+1。</li><li>非空二叉树第k层上至多有$2^{k-1}$个结点。</li><li>高度为h的二叉树至多有$2^h-1$个结点。</li><li>具有n个结点的完全二叉树的高度为$\lfloor log_2{n}\rfloor+1$或$\lceil log_2{n}+1 \rceil$</li><li>$2^{h-1}-1&lt;n&lt;=2^{h}-1$或$2^{h-1}&lt;=n&lt;2^h$</li></ol><h2 id="storage-structure"><a href="#storage-structure" class="headerlink" title="storage structure"></a>storage structure</h2><p>1.顺序存储结构</p><p>​    有一段连续的地址存储单元，自上而下，自左而右存储完全而完全二叉树上的结点。</p><p>​    缺点： 浪费空间</p><p>​    优点：好查找</p><p>2.链式结构存储</p><p><img src="/img/tree/1.png" alt="链式结构"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>ElemType data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;*BiTree,BiTNode;<br></code></pre></td></tr></table></figure><p>优点：空间利用率高</p><p>缺点：需要的查找时间长</p><h2 id="basic-operation"><a href="#basic-operation" class="headerlink" title="basic operation"></a>basic operation</h2><h3 id="链式结构下"><a href="#链式结构下" class="headerlink" title="链式结构下"></a>链式结构下</h3><h4 id="1-创建而二叉树"><a href="#1-创建而二叉树" class="headerlink" title="1.创建而二叉树"></a>1.创建而二叉树</h4><p>创建二叉树用的是二叉树的递归定义。</p><p>按先序遍历来创建二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateBitree</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<br><span class="hljs-keyword">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<span class="hljs-comment">//递归出口</span><br>T=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<span class="hljs-comment">//分配空间</span><br>        T.data=ch;<br>       <span class="hljs-built_in">CreateBitree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBitree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-先序遍历"><a href="#2-先序遍历" class="headerlink" title="2.先序遍历"></a>2.先序遍历</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreorderTraversal</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,T-&gt;data);<span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">PreorderTraversal</span>(T-&gt;lchild);<br>    <span class="hljs-built_in">PreorderTraversal</span>(T-&gt;rchild);<br></code></pre></td></tr></table></figure><h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreorderTraversal</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<br>    stack S;<br>    BiTree p=T;<br><span class="hljs-keyword">if</span>(T)&#123;<span class="hljs-comment">//非空树就遍历</span><br><span class="hljs-built_in">InitStack</span>(S);<span class="hljs-comment">//初始化栈</span><br>        <span class="hljs-keyword">while</span>(p||!<span class="hljs-built_in">IsEmpty</span>(S))&#123;<span class="hljs-comment">//栈里不空就可以遍历</span><br>        <span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">//往左边走到头</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,p-&gt;data);<span class="hljs-comment">//先访问根节点</span><br>            <span class="hljs-built_in">push</span>(S,p);<span class="hljs-comment">//根入栈</span><br>           p=p-&gt;lchild;<span class="hljs-comment">//指向左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">pop</span>(S,p);<span class="hljs-comment">//空了就出栈</span><br>            p=p-&gt;rchild;<br>        &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二叉树千变万变离不开这两个操作</strong></p><h4 id="3-层序遍历（非递归）"><a href="#3-层序遍历（非递归）" class="headerlink" title="3.层序遍历（非递归）"></a>3.层序遍历（非递归）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>LQueue Q;<br>    BiTree p=T;<br>    <span class="hljs-keyword">if</span>(T)&#123;<br><span class="hljs-built_in">InitQueue</span>(Q);<br>        <span class="hljs-built_in">EnQueue</span>(Q,p);<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(Q))&#123;<span class="hljs-comment">//每次把队头的孩子放进来，不空就队首出队，O(n)。</span><br>            <span class="hljs-built_in">DeQueue</span>(Q,p);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br>            <span class="hljs-keyword">if</span>(p-&gt;lchild)<span class="hljs-built_in">EnQueue</span>(Q,p-&gt;lchild);<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild)<span class="hljs-built_in">EnQueue</span>(Q,p-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>可以很轻松的实现层序遍历，但只能存完全二叉树。</p><h4 id="1-层序遍历（输入）"><a href="#1-层序遍历（输入）" class="headerlink" title="1.层序遍历（输入）"></a>1.层序遍历（输入）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> bitree[<span class="hljs-number">100010</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;bitree[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-先序遍历-1"><a href="#2-先序遍历-1" class="headerlink" title="2.先序遍历"></a>2.先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreorderTraversal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bitree[],<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(u&gt;n)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,bitree[i]);<br>    <span class="hljs-built_in">PreorderTraversal</span>(bitree,u*<span class="hljs-number">2</span>,n);<br>    <span class="hljs-built_in">PreorderTraversal</span>(bitree,u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,n);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要利用的是二叉树的性质。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tree</title>
    <link href="/2021/10/21/tree/"/>
    <url>/2021/10/21/tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><h3 id="1-definition"><a href="#1-definition" class="headerlink" title="1.definition"></a>1.definition</h3><p>​        树是n个（n&gt;=0）节点的有限集。当n=0时，称为空树。 在任意一棵非空树中应满足：</p><p>​        1.有且仅有一个特定的称为根的节点</p><p>​        2.当n&gt;1时, 其余节点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一颗树，并            且称为根的子树。</p><p>​        这个定义很明显是递归定义，即在树的定义中用到了自身。</p><p>​        树是一种递归的数据结构。</p><p>​        树作为一种逻辑结构具有以下两个特点：</p><p>​            1）树的根节点没有前驱，除根结点以外所有节点有且只有一个前驱。</p><p>​            2）树的所有节点可以拥有0或多个后继。</p><h3 id="2-trem"><a href="#2-trem" class="headerlink" title="2.trem"></a>2.trem</h3><p>​        树的高：数的最大层数。</p><p>​        节点的度：节点的孩子个数。（这里要区分离散数学里的度）</p><p>​        树的度：节点度最大的数</p><p>​        叶子节点：度为0的节点。</p><p>​        有序树：节点的左右子树从左到右有序。</p><p>​        无序树：节点的左右子树从左到右无序。</p><p>​        路径：两个节点的路径是这两个节点之间所经过节点序列构成的。</p><p>​        路径长度： 路径上所经过的边的个数。</p><h3 id="3-property"><a href="#3-property" class="headerlink" title="3.property"></a>3.property</h3><p>​        1）节点数=节点度数之和+1</p><p>​        2）度为m的树上，第i层至多有$m^{i-1}$个节点。</p><p>​        3）高为h的m叉树至多有（$m^{h}$-1)(m-1)。</p><p>​        4）n个节点的m叉树的最小高度为$\log_m^{n(m-1)+1}$</p><h3 id="4-fores"><a href="#4-fores" class="headerlink" title="4.fores"></a>4.fores</h3><p>​        m棵互不相交树的集合。（他可以和书相互转换）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2021/09/29/KMP/"/>
    <url>/2021/09/29/KMP/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>1.朴素算法</p><p>2.KMP算法的过程</p><p>3.next数组求法</p><p>4.KMP算法代码实现</p><p>5.next数组优化</p><h2 id="1-朴素算法"><a href="#1-朴素算法" class="headerlink" title="1.朴素算法"></a>1.朴素算法</h2><p>  字符串匹配的朴素算法是文本串T与匹配串P逐个比较的过程。</p><p><img src="/img/KMP/1.png" alt="朴素算法图"></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string T,string P)</span></span>&#123;<br><span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;T.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//遍历T中元素 </span><br><span class="hljs-keyword">if</span>(T[i]==P[j])i++,j++;<span class="hljs-comment">//对T[i]与P[j]对比，相等就比较下一位。 </span><br><span class="hljs-keyword">else</span> &#123; <br>i=i-j+<span class="hljs-number">1</span>;<span class="hljs-comment">//不等就i指针到刚开始的下一位，j从头开始 </span><br>j=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(j==P.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//模式串匹配完，输出文本串的开始匹配的位置.</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i-j);<br>&#125;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-KMP算法的过程"><a href="#2-KMP算法的过程" class="headerlink" title="2.KMP算法的过程"></a>2.KMP算法的过程</h2><p>​    KMP算法就比较机智的利用模式串中本身蕴含的信息跳过了一些不必要被比较。</p><p>如下图，匹配失败，j回到图示绿色位置而i不变化，这样可以减少下一次比较次数且不会有丢落，原因就是P1,P2和S1串相同，我们利用已知的信息可以跳过从头开始比较相同子串的过程，并且这样相同的子串越长可节约的时间就越多。</p><p><img src="/img/KMP2.png" alt="KMP过程图"></p><h2 id="3-next数组求法"><a href="#3-next数组求法" class="headerlink" title="3.next数组求法"></a>3.next数组求法</h2><p><a href="https://www.bilibili.com/video/BV1hW411a7ys?spm_id_from=333.999.0.0">KMP字符串匹配算法2_哔哩哔哩_bilibili</a></p><p>下面的解释看到6：20就行。</p><p>​    于是我们需要初始化求得一个信息表（next数组），来记录每一个字符前子串中的前缀与后缀相同的最大长度（前缀是不含子串最后一个字符的，同理后缀），并且这种性质一定藏在模式串P中，所以我们无需考虑文本串T,只对P操作就可以。</p><p>​    比如：P: $abaabcac$</p><p>​    0: a—没有相同   —下一个为a才行</p><p>​    1: ab—最大前缀是a，最大后缀是b，没相同  —下一个为a才行</p><p>​    2: aba—前缀是a，后缀是a最大，为1    —下一个字符要想加入最大前后缀必须为b</p><p>​    3: abaa—不是b,但和首字符相同，为1    —下一个字符要想加入最大前后缀必须为b</p><p>​    4:abaab—是b 为2    —下一个字符要想加入最大前后缀必须为a</p><p>​    5:abaabc—不是a, 回到0:也不行，为0  —下一个为a才行</p><p>​    6:abaabca—是a, 为1    —下一个为b才行对应2的条件</p><p>​    可以看出这是一个递归的求解，下一个与前一个有关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(string P,<span class="hljs-keyword">int</span> next[])</span></span>&#123;<br>i=<span class="hljs-number">1</span>;next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;P[<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||P[i]==P[j])&#123;i++;j++;next[i]=j;&#125;<br>        <span class="hljs-keyword">else</span> j=next[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/KMP/3.png" alt="next"></p><pre><code>## 4.KMP算法代码实现</code></pre><p>KMP算法算法实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> T[],<span class="hljs-keyword">char</span> P[])</span></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span>  ne[<span class="hljs-number">100010</span>];<br>n=<span class="hljs-built_in">strlen</span>(T);<br>m=<span class="hljs-built_in">strlen</span>(P);<br><span class="hljs-built_in">get_next</span>(P,ne);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,p=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">while</span>(p&gt;<span class="hljs-number">0</span>&amp;&amp;T[i]!=P[p])<span class="hljs-comment">//递归可以节约的点</span><br>p=ne[p<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(T[i]==P[p])p++;<span class="hljs-comment">//匹配上就比较下一个</span><br><span class="hljs-keyword">if</span>(p==m)cout&lt;&lt;i-p+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-next数组优化"><a href="#5-next数组优化" class="headerlink" title="5.next数组优化"></a>5.next数组优化</h2><p>可以看出当T与P匹配不上时就去查找对应信息表，一直只查到可以匹配上或者开头。于是在get_next时就可以直接递归到位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(<span class="hljs-keyword">char</span> p[],<span class="hljs-keyword">int</span>* ne)</span></span>&#123;<br><span class="hljs-keyword">int</span> m;<br>m=<span class="hljs-built_in">strlen</span>(p);<br>ne[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>&amp;&amp;p[i]!=p[k])<br>k=p[k<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(p[i]==p[k])&#123;<br>k++;<br>&#125;<br>ne[i]=k;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AcWing版代码"><a href="#AcWing版代码" class="headerlink" title="AcWing版代码"></a>AcWing版代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000010</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> ne[N];<br><span class="hljs-keyword">char</span> T[N],P[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make_next</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br><span class="hljs-keyword">while</span>(j&amp;&amp;P[i]!=P[j])j=ne[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(P[i]==P[j])j++;<br>        ne[i]=j;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">make_next</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">while</span>(j&amp;&amp;T[i]!=P[j])j=ne[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(T[i]==P[j])j++;<br>        <span class="hljs-keyword">if</span>(j==m)cout&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;m&gt;&gt;P&gt;&gt;n&gt;&gt;T;<br>    <span class="hljs-built_in">kmp</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C string to float number</title>
    <link href="/2021/09/14/C-string-to-float-number/"/>
    <url>/2021/09/14/C-string-to-float-number/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>c=getchar();<br><span class="hljs-keyword">double</span> data=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> tans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<span class="hljs-comment">//#输入结束</span><br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>flag=<span class="hljs-literal">false</span>;<br>c=getchar();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(flag)data=data*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">else</span> &#123;<br>tans*=<span class="hljs-number">0.1</span>;<br>data+=tans*(c-<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;<br>c=getchar();<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My first blog</title>
    <link href="/2021/09/12/my-first-blog/"/>
    <url>/2021/09/12/my-first-blog/</url>
    
    <content type="html"><![CDATA[<p>​    I cross a vary hard way to get a blog which to record my experience.</p>]]></content>
    
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
