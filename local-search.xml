<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>完全背包</title>
    <link href="/2022/01/19/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    <url>/2022/01/19/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>有 N 种物品和一个容量是 V 的背包，每种物品都<strong>有无限件可用</strong>。</p><p>第 i 种物品的体积是 v[i]，价值是 w[i]。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由01背包的只有一件变为了有无限件，多加一重循环就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> v[N],w[N];<br><span class="hljs-keyword">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m;j&gt;=v[i];j--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;j&gt;=k*v[i];k++)<span class="hljs-comment">//枚举个数</span><br>dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-k*v[i]]+k*w[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dp[m]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>$dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i],dp[i-1][j-2<em>v[i]]+2</em>w[i],…,dp[i-1][j-k<em>v[i]]+k</em>w[i])$</p><p>$dp[i][j-v[i]]=max(dp[i-1][j-v[i]],dp[i-1][j-2<em>v[i]]+2</em>w[i],dp[i-1][j-3<em>v[i]]+3</em>w[i],…,dp[i-1][j-k<em>v[i]]+k</em>w[i])$ </p><p>可以发现dp[j]的dp[j]后面的项是就是dp[j-v[i]]，于是$dp[i][j]=max(dp[i-1][j],dp[i][j-v[i]])$</p><p>只要将体积正向计算就可以先计算出$dp[i][j-v[i]]$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> v[N],w[N];<br><span class="hljs-keyword">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=v[i];j&lt;=m;j++)<br>        &#123;<br>dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dp[m]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01背包</title>
    <link href="/2022/01/18/01%E8%83%8C%E5%8C%85/"/>
    <url>/2022/01/18/01%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>有 N 件物品和一个容量是 V 的背包。每件物品<strong>只能使用一次。</strong></p><p>第 i件物品的体积是 v[i]，价值是 w[i]。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h2 id="dfs解法"><a href="#dfs解法" class="headerlink" title="dfs解法"></a>dfs解法</h2><p>我们最容易想到的就是穷举所有情况，找到最大的价值</p><p>基本思想就是分类讨论</p><p>分为两类：</p><ol><li>装入第i个物品：考虑其余合理情况（在体积足够的情况下装入的最多）</li><li>不装入第i个物品：考虑其余合理情况（在体积足够的情况下装入的最多）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1010 </span><br><span class="hljs-keyword">int</span> dp[N];<br><span class="hljs-keyword">int</span> v[N],w[N],V;<br><span class="hljs-keyword">int</span> st[N];<br><span class="hljs-keyword">int</span> n,c;<br><span class="hljs-comment">/*void dfs(int u,int cur,int &amp;res)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    if(u==0)return;</span><br><span class="hljs-comment">    for(int i=0;i&lt;n;i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        if(!st[i]&amp;&amp;u-v[i]&gt;=0)&#123;</span><br><span class="hljs-comment">            st[i]=true;</span><br><span class="hljs-comment">            res=max(res,cur+w[i]);</span><br><span class="hljs-comment">            dfs(u-v[i],cur+w[i],res);</span><br><span class="hljs-comment">            st[i]=false;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res;<br>    <span class="hljs-keyword">if</span>(i==n)res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(u&lt;v[i])<br>    &#123;<br>res=<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,u);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>res=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,u),<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,u-v[i])+w[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[i][u]=res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(c,<span class="hljs-number">0</span>,ans);<br>    cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="记忆和搜索"><a href="#记忆和搜索" class="headerlink" title="记忆和搜索"></a>记忆和搜索</h2><p>显然当我们计算过程中有些值是已经被计算过的，而我们有重复计算了一遍。</p><p>这时记录已经算过的部分就可以避免重复计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1010 </span><br><span class="hljs-keyword">int</span> dp[N][N];<br><span class="hljs-keyword">int</span> v[N],w[N];<br><br><span class="hljs-keyword">int</span> n,c;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dp[i][u]&gt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> dp[i][u];<br>    <span class="hljs-keyword">int</span> res;<br>    <span class="hljs-keyword">if</span>(i==n) res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(u&lt;v[i])<br>    &#123;<br>        res=<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,u);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        res=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,u),<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,u-v[i])+w[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[i][u]=res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;c;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,c);<br>    <br>    cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="记忆化搜索转化为dp"><a href="#记忆化搜索转化为dp" class="headerlink" title="记忆化搜索转化为dp"></a>记忆化搜索转化为dp</h2><p>由记忆化搜索可以看出$dp[i][u]只和dp[i+1][u]and dp[i+1][u-v[i]]$有关</p><p>只要先算出i+1的和比u小的部分就可以计算$dp[i][u]$,因此有了for循环的顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1010 </span><br><span class="hljs-keyword">int</span> dp[N][N];<br><span class="hljs-keyword">int</span> v[N],w[N],V;<br><span class="hljs-keyword">int</span> n,c;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=c;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j&gt;=v[i])dp[i][j]=<span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j-v[i]]+w[i]);<br>            <span class="hljs-keyword">else</span> dp[i][j]=dp[i+<span class="hljs-number">1</span>][j];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">0</span>][c]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="对其空间进行优化"><a href="#对其空间进行优化" class="headerlink" title="对其空间进行优化"></a>对其空间进行优化</h2><p>$首先看dp[i][u]中i这一维，只用到了i+1,也就是说每次只用保留上一次的结果就可以了$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1010 </span><br><span class="hljs-keyword">int</span> dp[<span class="hljs-number">2</span>][N];<br><span class="hljs-keyword">int</span> v[N],w[N],V;<br><span class="hljs-keyword">int</span> n,c;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=c;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j&gt;=v[i])dp[i&amp;<span class="hljs-number">1</span>][j]=<span class="hljs-built_in">max</span>(dp[(i+<span class="hljs-number">1</span>)&amp;<span class="hljs-number">1</span>][j],dp[(i+<span class="hljs-number">1</span>)&amp;<span class="hljs-number">1</span>][j-v[i]]+w[i]);<span class="hljs-comment">//只用区分这次和上次就可以了</span><br>            <span class="hljs-keyword">else</span> dp[i&amp;<span class="hljs-number">1</span>][j]=dp[(i+<span class="hljs-number">1</span>)&amp;<span class="hljs-number">1</span>][j];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">0</span>][c]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>然后我们在更新dp的过程中又会发现，如果将体积倒着更新就会在更新时用到上一次的结果，于是可以彻底将i这一维去除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1010 </span><br><span class="hljs-keyword">int</span> dp[N];<br><span class="hljs-keyword">int</span> v[N],w[N],V;<br><span class="hljs-keyword">int</span> n,c;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=c;j&gt;=v[i];j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j&gt;=v[i])dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[c]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>这就是最终的01背包的代码</p><p>image<img src="/img/%E7%AE%97%E6%B3%95/01%E8%83%8C%E5%8C%85.png" alt="图解"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2022/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>数据库：data base(db)数据仓库，一堆文件里记录一堆信息。</p><p>数据库管理系统：data base management(DBMS)管理数据库中的数据的工具，对数据进行增删改查。</p><p>常见的数据库管理系统：MySQL、Oracle、DB2…</p><p>SQL: 结构化查询语言，DBMS执行语句来操控数据。他是通用的语言。</p><p>端口号是：3306</p><p>一些常见命令：</p><ol><li><p>show databases; (展示所有的库)</p></li><li><p>show tables; (展示所有的库)</p></li><li><p>use 名字 ; （使用库）</p></li><li><p>create 名字; （创建库）</p></li><li><p>source 地址 （导入库）</p></li><li><p>select* from 名字（从库里查表）</p></li><li><p>desc 名字 （查表的结构）</p></li><li><p>select 名字1 from 名字2 (从名字2里查名字1)</p><p>select dname,deptno from dept （查两个）</p><p>select* from 名字（都查）</p><p>select dname as deptname,deptno from dept (将deptno起别名，as可省)</p><p>select dname deptname,deptno from dept;</p><p>select dname ‘dept name’,deptno from dept;</p><p>select dname “dept name”,deptno from dept;  //orical里用不了</p></li></ol><p><strong>基本单元是表</strong></p><p><strong>SQL语句分类：</strong></p><p>DQL：</p><p>​        数据查询语言（带有select）</p><p>DML：</p><p>​        数据操作语言（对数据进行增删改）</p><p>​        insert  delete  update</p><p>DDL：</p><p>​        数据定义语言（带有create\drop\alter）</p><p>​        操作的是表的结构，删字段，加字段</p><p>TCL：</p><p>​        事务控制语言</p><p>​        包括：</p><p>​                事务提交：commit</p><p>​                事务回滚：rollback</p><p>DCL：</p><p>​        数据控制语言</p><p>​        例如：授权grant\撤销授权revoke </p><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>导入一个库要先使用这个库</p><p>里面有好几个表</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------------------+</span><br><span class="hljs-section">| Tables_in_bjpowernode |</span><br><span class="hljs-section">+-----------------------+</span><br>| dept                  |<br>| emp                   |<br><span class="hljs-section">| salgrade              |</span><br><span class="hljs-section">+-----------------------+</span><br></code></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">//select<span class="hljs-symbol">*</span> from emp<br>+-------+--------+-----------+------+------------+---------+---------+--------+<br>|<span class="hljs-string"> EMPNO </span>|<span class="hljs-string"> ENAME  </span>|<span class="hljs-string"> JOB       </span>|<span class="hljs-string"> MGR  </span>|<span class="hljs-string"> HIREDATE   </span>|<span class="hljs-string"> SAL     </span>|<span class="hljs-string"> COMM    </span>|<span class="hljs-string"> DEPTNO </span>|<br>+-------+--------+-----------+------+------------+---------+---------+--------+<br>|<span class="hljs-string">  7369 </span>|<span class="hljs-string"> SMITH  </span>|<span class="hljs-string"> CLERK     </span>|<span class="hljs-string"> 7902 </span>|<span class="hljs-string"> 1980-12-17 </span>|<span class="hljs-string">  800.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     20 </span>|<br>|<span class="hljs-string">  7499 </span>|<span class="hljs-string"> ALLEN  </span>|<span class="hljs-string"> SALESMAN  </span>|<span class="hljs-string"> 7698 </span>|<span class="hljs-string"> 1981-02-20 </span>|<span class="hljs-string"> 1600.00 </span>|<span class="hljs-string">  300.00 </span>|<span class="hljs-string">     30 </span>|<br>|<span class="hljs-string">  7521 </span>|<span class="hljs-string"> WARD   </span>|<span class="hljs-string"> SALESMAN  </span>|<span class="hljs-string"> 7698 </span>|<span class="hljs-string"> 1981-02-22 </span>|<span class="hljs-string"> 1250.00 </span>|<span class="hljs-string">  500.00 </span>|<span class="hljs-string">     30 </span>|<br>|<span class="hljs-string">  7566 </span>|<span class="hljs-string"> JONES  </span>|<span class="hljs-string"> MANAGER   </span>|<span class="hljs-string"> 7839 </span>|<span class="hljs-string"> 1981-04-02 </span>|<span class="hljs-string"> 2975.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     20 </span>|<br>|<span class="hljs-string">  7654 </span>|<span class="hljs-string"> MARTIN </span>|<span class="hljs-string"> SALESMAN  </span>|<span class="hljs-string"> 7698 </span>|<span class="hljs-string"> 1981-09-28 </span>|<span class="hljs-string"> 1250.00 </span>|<span class="hljs-string"> 1400.00 </span>|<span class="hljs-string">     30 </span>|<br>|<span class="hljs-string">  7698 </span>|<span class="hljs-string"> BLAKE  </span>|<span class="hljs-string"> MANAGER   </span>|<span class="hljs-string"> 7839 </span>|<span class="hljs-string"> 1981-05-01 </span>|<span class="hljs-string"> 2850.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     30 </span>|<br>|<span class="hljs-string">  7782 </span>|<span class="hljs-string"> CLARK  </span>|<span class="hljs-string"> MANAGER   </span>|<span class="hljs-string"> 7839 </span>|<span class="hljs-string"> 1981-06-09 </span>|<span class="hljs-string"> 2450.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     10 </span>|<br>|<span class="hljs-string">  7788 </span>|<span class="hljs-string"> SCOTT  </span>|<span class="hljs-string"> ANALYST   </span>|<span class="hljs-string"> 7566 </span>|<span class="hljs-string"> 1987-04-19 </span>|<span class="hljs-string"> 3000.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     20 </span>|<br>|<span class="hljs-string">  7839 </span>|<span class="hljs-string"> KING   </span>|<span class="hljs-string"> PRESIDENT </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string"> 1981-11-17 </span>|<span class="hljs-string"> 5000.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     10 </span>|<br>|<span class="hljs-string">  7844 </span>|<span class="hljs-string"> TURNER </span>|<span class="hljs-string"> SALESMAN  </span>|<span class="hljs-string"> 7698 </span>|<span class="hljs-string"> 1981-09-08 </span>|<span class="hljs-string"> 1500.00 </span>|<span class="hljs-string">    0.00 </span>|<span class="hljs-string">     30 </span>|<br>|<span class="hljs-string">  7876 </span>|<span class="hljs-string"> ADAMS  </span>|<span class="hljs-string"> CLERK     </span>|<span class="hljs-string"> 7788 </span>|<span class="hljs-string"> 1987-05-23 </span>|<span class="hljs-string"> 1100.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     20 </span>|<br>|<span class="hljs-string">  7900 </span>|<span class="hljs-string"> JAMES  </span>|<span class="hljs-string"> CLERK     </span>|<span class="hljs-string"> 7698 </span>|<span class="hljs-string"> 1981-12-03 </span>|<span class="hljs-string">  950.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     30 </span>|<br>|<span class="hljs-string">  7902 </span>|<span class="hljs-string"> FORD   </span>|<span class="hljs-string"> ANALYST   </span>|<span class="hljs-string"> 7566 </span>|<span class="hljs-string"> 1981-12-03 </span>|<span class="hljs-string"> 3000.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     20 </span>|<br>|<span class="hljs-string">  7934 </span>|<span class="hljs-string"> MILLER </span>|<span class="hljs-string"> CLERK     </span>|<span class="hljs-string"> 7782 </span>|<span class="hljs-string"> 1982-01-23 </span>|<span class="hljs-string"> 1300.00 </span>|<span class="hljs-string">    NULL </span>|<span class="hljs-string">     10 </span>|<br>+-------+--------+-----------+------+------------+---------+---------+--------+<br></code></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">//desc 查emp的结构<br>+----------+-------------+------+-----+---------+-------+<br>|<span class="hljs-string"> Field    </span>|<span class="hljs-string"> Type        </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Key </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Extra </span>|<br>+----------+-------------+------+-----+---------+-------+<br>|<span class="hljs-string"> EMPNO    </span>|<span class="hljs-string"> int(4)      </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> PRI </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> ENAME    </span>|<span class="hljs-string"> varchar(10) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> JOB      </span>|<span class="hljs-string"> varchar(9)  </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> MGR      </span>|<span class="hljs-string"> int(4)      </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> HIREDATE </span>|<span class="hljs-string"> date        </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> SAL      </span>|<span class="hljs-string"> double(7,2) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> COMM     </span>|<span class="hljs-string"> double(7,2) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> DEPTNO   </span>|<span class="hljs-string"> int(2)      </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>+----------+-------------+------+-----+---------+-------+<br></code></pre></td></tr></table></figure><h2 id="字段使用数学表达式"><a href="#字段使用数学表达式" class="headerlink" title="字段使用数学表达式"></a>字段使用数学表达式</h2><p>select ename,sal*12 from emp;</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2022/01/12/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2022/01/12/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><p>求组合数有四种情况</p><h2 id="10万组-1-lt-b-lt-a-lt-2000"><a href="#10万组-1-lt-b-lt-a-lt-2000" class="headerlink" title="10万组  1&lt;=b&lt;=a&lt;=2000"></a>10万组  1&lt;=b&lt;=a&lt;=2000</h2><p>用递推 $N^2$</p><p>$C_a^b=C_{a-1}^b+C_{a-1}^{b-1}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2020</span>,mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> c[N][N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)<br>        &#123;<br><span class="hljs-keyword">if</span>(!j)c[i][j]=<span class="hljs-number">1</span>;<br>             <span class="hljs-keyword">else</span> c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1万组-1-lt-b-lt-a-lt-10-5"><a href="#1万组-1-lt-b-lt-a-lt-10-5" class="headerlink" title="1万组 $1&lt;=b&lt;=a&lt;=10^5$"></a>1万组 $1&lt;=b&lt;=a&lt;=10^5$</h2><p>预处理  NlogN</p><p>先预处理出阶乘和逆元阶乘</p><p>用阶乘公式来计算：$C_a^b= \frac {a!}{b! \times {(a-b)!}} $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-function">ll <span class="hljs-title">qmi</span><span class="hljs-params">(ll a,ll b,ll p)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll tmp=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)tmp=(tmp*a)%mod;<br>        a=a*a%mod;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-keyword">int</span> fact[<span class="hljs-number">100010</span>],infact[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">0</span>]=infact[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">100010</span>;i++)<br>    &#123;<br>        fact[i]=(ll)fact[i<span class="hljs-number">-1</span>]*i%mod;<br>        infact[i]=(ll)infact[i<span class="hljs-number">-1</span>]*<span class="hljs-built_in">qmi</span>(i,mod<span class="hljs-number">-2</span>,mod)%mod;<span class="hljs-comment">//求逆元</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(ll)fact[a]*infact[b]%mod*infact[a-b]%mod);<span class="hljs-comment">//公式</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-组-1-lt-b-lt-a-lt-10-18-1-lt-p-lt-10-5"><a href="#20-组-1-lt-b-lt-a-lt-10-18-1-lt-p-lt-10-5" class="headerlink" title="20 组 $1&lt;=b&lt;=a&lt;=10^{18} 1&lt;=p&lt;={10^5}$"></a>20 组 $1&lt;=b&lt;=a&lt;=10^{18} 1&lt;=p&lt;={10^5}$</h2><p>利用卢卡斯定理:$C_a^b mod p=C_{a mod p}^{b mod p} \times C_{a/p}^{b/p} mod p$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br>LL p;<br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(LL a,LL k)</span><span class="hljs-comment">//都是LL就对了</span></span><br><span class="hljs-function"></span>&#123;<br>    LL tmp=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>)tmp=tmp*a%p;<br>        a=a*a%p;<br>        k&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">C</span><span class="hljs-params">(LL a,LL b)</span></span>&#123;<br>    LL res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=a;i&lt;=b;i++,j--)<span class="hljs-comment">//i从1开始</span><br>    &#123;<br>        res=(LL)res*j%p;<br>        res=(LL)res*<span class="hljs-built_in">qmi</span>(i,p<span class="hljs-number">-2</span>)%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">lucas</span><span class="hljs-params">(LL a,LL b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&lt;p&amp;&amp;b&lt;p)<span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a,b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (LL)<span class="hljs-built_in">C</span>(a%p,b%p)*<span class="hljs-built_in">lucas</span>(a/p,b/p)%p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        LL a,b;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;<br>        LL t = <span class="hljs-built_in">lucas</span>(a,b);<br>        cout&lt;&lt;t&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="大数不取模"><a href="#大数不取模" class="headerlink" title="大数不取模"></a>大数不取模</h2><p>方法是高精度计算</p><ol><li>筛质数</li><li>先处理出质因子个数</li><li>高精度乘法</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> pir[<span class="hljs-number">5010</span>],cnt;<br><span class="hljs-keyword">int</span> st[<span class="hljs-number">5010</span>];<br><span class="hljs-keyword">int</span> sum[<span class="hljs-number">5010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i])pir[cnt++]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;pir[j]&lt;=n/i;j++)<br>        &#123;<br>            st[pir[j]*i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%pir[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a)<br>    &#123;<br>        res+=a/p;<br>        a/=p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; c;<br>    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        t+=a[i]*b;<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)<br>    &#123;<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-built_in">get_primes</span>(a);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> p=pir[i];<br>        sum[i]=<span class="hljs-built_in">get</span>(a,p)-<span class="hljs-built_in">get</span>(b,p)-<span class="hljs-built_in">get</span>(a-b,p);<br>    &#125;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;sum[i];j++)<br>        &#123;<br>            res=<span class="hljs-built_in">mul</span>(res,pir[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)cout&lt;&lt;res[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划note</title>
    <link href="/2022/01/10/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92note/"/>
    <url>/2022/01/10/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92note/</url>
    
    <content type="html"><![CDATA[<h1 id="欧拉计划"><a href="#欧拉计划" class="headerlink" title="欧拉计划"></a>欧拉计划</h1><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>判断回文数：</p><ol><li>数字回文：直接倒过来判断是否与原数字相等</li><li>字符串回文：看一半和另一半是否相等</li></ol><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>最小公倍数</p><ol><li>两个数的：$ \frac {a \times b} {gcd(a,b)}$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> ans=(a*b)/<span class="hljs-built_in">gcd</span>(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li> 多个数的：先把这几个数的质因数写出来，最小公倍数等于它们所有的质因数的乘积（如果有几个质因数相同，则比较两数中哪个数有该质因数的个数较多，乘较多的次数）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//求1~20的最小公倍数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">100010</span>];<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(b));<br><span class="hljs-keyword">int</span> res=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/i;i++)<br>&#123;<br><span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>n/=i;<br>b[i]++;<br><span class="hljs-keyword">if</span>(b[i]&gt;a[i])&#123;<br>a[i]=b[i];<br>res*=i;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)&#123;<br>b[n]++;<br><span class="hljs-keyword">if</span>(b[n]&gt;a[n])&#123;<br>a[n]=b[n];<br>res*=n;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">20</span>;i++)<br>&#123;<br>ans*=<span class="hljs-built_in">f</span>(i);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>就是纯数学推导</p><p>减去平方项，就剩下$C_2^1 \sum_1^{100}\sum_{i+1}^{100}i*j $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">100</span>;j++)<br>&#123;<br>ans+=i*j;<br>&#125;<br>cout&lt;&lt;<span class="hljs-number">2</span>*ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> pir[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">int</span> st[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">num</span><span class="hljs-params">(n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i])pir[cnt++]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;pir[j]&lt;=x/i;j++)<br>        &#123;<br>             st[pir[j]*i]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(i%pir[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>就是暴力，易错点是0的考虑，一开始我把他当浮点数去算结果也不对，后来看了来看答案发现可以记录0的个数。模拟个入栈出栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s=<span class="hljs-string">&quot;7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> z_num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> max=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(s[i]!=<span class="hljs-string">&#x27;0&#x27;</span>)t*=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">else</span>  z_num++;<br><span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">13</span>)&#123;<br><span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-13</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)z_num--;<br><span class="hljs-keyword">else</span> t/=s[i<span class="hljs-number">-13</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(z_num==<span class="hljs-number">0</span>&amp;&amp;t&gt;max)max=t;<br>&#125;<br>cout&lt;&lt;max;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p>auto是c++11中的东西，用的是约数个数的公式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> n;<br>    <br>    <span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;;k++)<br>    &#123;<br>        sum+=k;<br>        m=sum;<br>        cout&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; primes;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=m/i;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(m%i==<span class="hljs-number">0</span>)<br>            &#123;<br>    <br>                m/=i;<br>                <br>                primes[i]++;<br>                <br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(m&gt;<span class="hljs-number">1</span>)primes[m]++;<span class="hljs-comment">//这里有个性质：n中最多只含有一个大于sqrt(n)的因子。证明通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕</span><br>    <br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">1</span>;<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> prime:primes)res=res*(prime.second+<span class="hljs-number">1</span>);<br>        cout&lt;&lt;res&lt;&lt;endl;<br>        <span class="hljs-keyword">if</span>(res&gt;=<span class="hljs-number">500</span>)<br>        &#123;<br>            cout&lt;&lt;sum&lt;&lt;endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高斯消元</title>
    <link href="/2022/01/09/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    <url>/2022/01/09/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h1 id="高斯消元解线性方程组"><a href="#高斯消元解线性方程组" class="headerlink" title="高斯消元解线性方程组"></a>高斯消元解线性方程组</h1><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><p>初等行变换（不影响方程组的解）</p><ol><li>把某一行乘一个非0的数 (方程的两边同时乘上一个非0数不改变方程的解）</li><li>交换某两行</li><li>把某行的若干倍加到另一行上去（把一个方程的若干倍加到另一方程上去）</li></ol><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><ol><li>找到当前列的绝对值的最大一行</li><li>将该行换到相对最上面</li><li>将改行的第一个数变为1</li><li>将下面所有当前列的数变为0</li><li>重复1234</li><li>将上面的列的数变为0</li><li>重复6</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">110</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> esp=<span class="hljs-number">1e-8</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">double</span> a[N][N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> r,c;<br>    <span class="hljs-keyword">for</span>(c=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;c&lt;n;c++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> t=r;<br>        <span class="hljs-comment">//1找最大</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=r;i&lt;n;i++)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][c])&gt;<span class="hljs-built_in">fabs</span>(a[t][c]))t=i;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[t][c])&lt;esp)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//2交换</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=c;i&lt;=n;i++)<span class="hljs-built_in">swap</span>(a[r][i],a[t][i]);<br>        <span class="hljs-comment">//3归一</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;c;i++)a[r][i]/=a[r][c];<br>        <span class="hljs-comment">//4相减</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=r+<span class="hljs-number">1</span>;i&lt;n;i++)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][c])&gt;esp)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n;j&gt;=c;j--)<br>                &#123;<br>                    a[i][j]-=a[r][j]*a[i][c];<br>                &#125;<br>            &#125;<br>        r++;<br>    &#125;<br>    <span class="hljs-comment">//方程数小于未知量数</span><br>    <span class="hljs-keyword">if</span>(r&lt;n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=r;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i][n]&gt;esp)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//矛盾无解</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//不矛盾由无数解</span><br>    &#125;<br>    <span class="hljs-comment">//6</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//从最后一行开始到第一行</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//查看1后面有哪些系数应消除</span><br>        &#123;<br>            a[i][n]-=a[i][j]*a[j][n];<span class="hljs-comment">//a[i][j]是应消除的系数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//有唯一解返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>约数</title>
    <link href="/2022/01/03/%E7%BA%A6%E6%95%B0/"/>
    <url>/2022/01/03/%E7%BA%A6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><p>约数，又称<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111">因数</a>。<a href="https://baike.baidu.com/item/%E6%95%B4%E6%95%B0/1293937">整数</a>a除以整数b(b≠0) 除得的<a href="https://baike.baidu.com/item/%E5%95%86/3820976">商</a>正好是整数而没有<a href="https://baike.baidu.com/item/%E4%BD%99%E6%95%B0/6180737">余数</a>，我们就说a能被b整除，或b能整除a。a称为b的<a href="https://baike.baidu.com/item/%E5%80%8D%E6%95%B0/7827981">倍数</a>，b称为a的约数。</p><h2 id="求约数"><a href="#求约数" class="headerlink" title="求约数"></a>求约数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">get_yue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/i;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(n/i!=i)res.<span class="hljs-built_in">push_back</span>(n/i);<span class="hljs-comment">//在sqrt(n)左右对称，但不要重复</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//sort(res.begin(),res.end());</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两个性质"><a href="#两个性质" class="headerlink" title="两个性质"></a>两个性质</h2><ol><li><p>求所有约数的个数</p><p>公式：$(a_1+1)(a_2+1)…(a_n+1), a_i是对应质因数出现的次数$</p><p>证明：已知质因数及其个数，n是被分解的数，m是因数</p><p>$n=p_1^{a_1} \times p_2^{a_2} \times …\times p_n^{a_n}$</p><p>$m=p_1^{b_1} \times p_2^{b_2} \times …\times p_n^{b_n}$</p><p>b在0~a之间有a+1种选法</p><p>由乘法定理得：全部约数个数为$(a_1+1)(a_2+1)…(a_n+1)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//这里用哈希表存储质因数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">int</span> mod=(<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>)<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; primes;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/i;i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)<br>        &#123;<br>            primes[i]++;<br>            n/=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;i)primes[n]++;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> prime:primes)res=res*(prime.second+<span class="hljs-number">1</span>)%mod;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>求所有约数的和</p><p>由1证明,易知全部和为其质因数出实现次数之和在相乘$(p_1^0+p_1^1+…+p_1^{c1})∗…∗(p_k^0+p_k^1+…+p_k^{c_k})$</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; primes;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> m;<br>        cin&gt;&gt;m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=m/i;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(m%i==<span class="hljs-number">0</span>)<br>            &#123;<br><br>                m/=i;<br>                primes[i]++;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(m&gt;<span class="hljs-number">1</span>)primes[m]++;<br><br>    &#125;<br><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> prime:primes)&#123;<br>        <span class="hljs-keyword">int</span> p=prime.first,a=prime.second;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t=<span class="hljs-number">1</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">while</span>(a--)t=(t*p+<span class="hljs-number">1</span>)%(<span class="hljs-keyword">int</span>)(<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>);<span class="hljs-comment">//秦九韶求和</span><br>        res=res*(t)%(<span class="hljs-keyword">int</span>)(<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>);<span class="hljs-comment">//</span><br>    &#125;<br><br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="求解最大公约数"><a href="#求解最大公约数" class="headerlink" title="求解最大公约数"></a>求解最大公约数</h2><p>辗转相除法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b? <span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数</title>
    <link href="/2022/01/03/%E8%B4%A8%E6%95%B0/"/>
    <url>/2022/01/03/%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><p>质数：质数是指在大于1的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394">自然数</a>中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111">因数</a>的自然数。</p><h2 id="判断质数"><a href="#判断质数" class="headerlink" title="判断质数"></a>判断质数</h2><p>用定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=x;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)<span class="hljs-comment">//没有可以大于sqrt(x)的i</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：原因：素数是因子为1和本身， 如果数c不是素数，则还有其他因子，其中的因子，假如为a,b.其中必有一个大于sqrt(c) ，一个小于sqrt(c) 。所以m必有一个小于或等于其平方根的因数，那么验证素数时就只需要验证到其平方根就可以了。即一个合数一定含有小于它平方根的质因子。</p><h2 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/i;i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i);<br>            n/=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,n);<span class="hljs-comment">//假设有因子i&gt;sqrt(n),即n/i==0,那么它应当在i&lt;sqrt(n)时就会被发现——因为他对应的因子n/i&lt;sqrt(n)唯一的落网之鱼就是其本身就是质数，如37</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><p>//线筛</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> pir[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">int</span> st[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])pir[cnt++]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;pir[j]&lt;=x/i;j++)&#123;<br>            st[pir[j]*i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%pir[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2021/12/30/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2021/12/30/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>双指针是在暴力做法中发现一些性质，将时间复杂度降低。比如指针的单调性。</p><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=?;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j合理&amp;&amp;<span class="hljs-built_in">chack</span>(i,j))j++;<br>    <span class="hljs-comment">//相关逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长不包含重复连续子序列"><a href="#最长不包含重复连续子序列" class="headerlink" title="最长不包含重复连续子序列"></a>最长不包含重复连续子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<br><span class="hljs-comment">//s是记录是否出现过</span><br><span class="hljs-keyword">int</span> s[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    s[a[i]]++;<br>    <span class="hljs-keyword">while</span>(s[i]&gt;<span class="hljs-number">1</span>)&#123;<br>        s[a[j]]--;<br>        j++;<br>    &#125;<br>    res=<span class="hljs-built_in">max</span>(res,j-i+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组元素的目标和"><a href="#数组元素的目标和" class="headerlink" title="数组元素的目标和"></a>数组元素的目标和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>],b[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m,r;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)cin&gt;&gt;b[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=m<span class="hljs-number">-1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//朴素算法</span><br>        <span class="hljs-comment">// for(int j=0;j&lt;m;j++)&#123;</span><br>        <span class="hljs-comment">//     if(a[i]+b[j]==r)&#123;</span><br>        <span class="hljs-comment">//         cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;a[i]+b[j]&gt;r)j--;<br><br>        <span class="hljs-keyword">if</span>(a[i]+b[j]==r)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;j&lt;&lt;endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>a是b的子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)cin&gt;&gt;b[i];<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">while</span>(j&lt;m&amp;&amp;a[i]!=b[j])j++;<br>        <span class="hljs-keyword">if</span>(j!=m&amp;&amp;a[i]==b[j])&#123;<br>            cnt++;<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt==n)cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和と差分</title>
    <link href="/2021/12/29/%E5%89%8D%E7%BC%80%E5%92%8C%E3%81%A8%E5%B7%AE%E5%88%86/"/>
    <url>/2021/12/29/%E5%89%8D%E7%BC%80%E5%92%8C%E3%81%A8%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>就是数列前n项和</p><p>公式$S_n=S_{n-1}+a_n$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> s[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-comment">//s[0]=0;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将求某一区间的和的时间复杂度变为O（1）</p><p>求[a,b]和的公式：s=s[b]-a[a-1]</p><p>他还有二维形式前缀和</p><p>公式：$s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]$</p><p>求$（x_1,y_1），（x_2,y_2）$矩形内的和</p><p>公式：$s=s[x_2][y_2]-s[x_1-1][y_2]-s[x_2][y_1-1]+s[x_1-1][y_1-1]$</p><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>数列有前n项和求$a_n$</p><p>公式：a[n]=s[n]-s[n-1]</p><p>它可以直接将某一区间[a,b]加减c用O（1）</p><p>$原理是将a[a]+=c,a[b+1]-=c,这样既保证这个区间s_n是加上c了，而且[b, +\infty]还是不变$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> s[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;s[i];<br>        a[i]=s[i]-s[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-keyword">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        a[l]+=c;<br>        a[r+<span class="hljs-number">1</span>]-=c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>        cout&lt;&lt;s[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>他也有二维模式</p><p>$公式：a[i][j]=s[i][j]-s[i-1][j]-s[i][j-1]+s[i-1][j-1]+a[i][j]$<br>$$<br>某一矩形内[x_1,y_1],[x_2,y_2]的值加减c公式:<br>a[x_1][y_1]+=c,a[x_1][y_2+1]-=c,a[x_2+1][y_1]-=c,a[x_2+1][y_2+1]+=c<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2021/12/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/12/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>适用于有序的线性表</p><p>有三种模板</p><h3 id="判断是否存在"><a href="#判断是否存在" class="headerlink" title="判断是否存在"></a>判断是否存在</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(SqList L,<span class="hljs-keyword">int</span> target)</span></span>&#123;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=L.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L.ele[mid]==target)<span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L.ele[mid]&gt;target)r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最左端第一次出现的位置"><a href="#最左端第一次出现的位置" class="headerlink" title="最左端第一次出现的位置"></a>最左端第一次出现的位置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span></span>&#123;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;=target)r=mid<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最右端第一次出现的位置"><a href="#最右端第一次出现的位置" class="headerlink" title="最右端第一次出现的位置"></a>最右端第一次出现的位置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span></span>&#123;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br><span class="hljs-keyword">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;=target)l=mid;<br>        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“神农”</title>
    <link href="/2021/12/26/%E7%A5%9E%E5%86%9C/"/>
    <url>/2021/12/26/%E7%A5%9E%E5%86%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="菖蒲"><a href="#菖蒲" class="headerlink" title="菖蒲"></a>菖蒲</h2><p>味辛，性温，治风寒湿痹、咳逆上气，开心孔，补五脏，通九窍，明耳目，出音声。久服轻身，不忘，不迷惑，延年。一名昌阳。生池泽。</p><h3 id="附方"><a href="#附方" class="headerlink" title="附方"></a>附方</h3><ol><li>菖蒲羹：治耳聋耳鸣如风水生。菖蒲60克，猪肾一对，葱白3根，米300克。以水先煮菖蒲，去滓，入猪肾、葱白、米及五味作羹，召唤常法空腹食。</li><li>治痰迷心窍：菖蒲、生姜，共捣汁灌下。</li><li>治中风不语，口眼歪斜：鲜菖蒲、冰糖各15克，以开水炖服。</li><li>治痰阻心窍，神志不清：菖蒲、远志、天竺黄各10克，以水煎服。</li><li>治诸般赤眼，攀晴云翳：菖蒲自然汁，文武火煎熬作膏，日点之。</li><li>治水肿：鲜菖蒲10克，黄豆60克，以水煮服。</li></ol><h2 id="菊花"><a href="#菊花" class="headerlink" title="菊花"></a>菊花</h2><p>味苦，平。治风头眩、肿痛、目欲脱、泪出、皮肤死肌、恶风湿痹。久服利血气，轻身耐老延年。一名节华。生川泽。</p><h3 id="附方-1"><a href="#附方-1" class="headerlink" title="附方"></a>附方</h3><ol><li>菊花酒：10月菊花盛开时，采摘菊花去蒂，取纯净者1000克，泡在5升好酒中，密封10天，即可饮用。</li><li>治关节肿大疼痛：用菊花、陈艾作护膝，长期使用则自愈。</li><li>治风热头痛：菊花、石膏、川芎各15克为末，每次7.5克，用茶调下。</li><li>治女子阴肿：用柑橘苗捣烂熬汤。先熏后洗。</li><li>菊花散：菊花30克，细辛、附子、桂心、干姜、人参、石楠叶、天雄、茯苓、秦艽、山菜萸、防己、防风、白术、山药各90克，蜀椒15克，以上17味，共为细末，服10克，日三次。治头面游风。</li></ol><h3 id="主治"><a href="#主治" class="headerlink" title="主治"></a>主治</h3><p>散风清热，平肝明目。用于风热感冒、头晕目眩、目赤肿痛、眼目昏花。野菊花清热解毒，目赤肿痛、头晕目眩。</p><h2 id="人参"><a href="#人参" class="headerlink" title="人参"></a>人参</h2><p>人参，味甘，微甜。补五脏，安精神，定魂魄，止惊悸，除邪气名目，开心，益智。久服轻身延年。一名人街，一名鬼盖。生山谷。</p>]]></content>
    
    
    <categories>
      
      <category>医</category>
      
      <category>药</category>
      
    </categories>
    
    
    <tags>
      
      <tag>药</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>moon</title>
    <link href="/2021/12/19/moon/"/>
    <url>/2021/12/19/moon/</url>
    
    <content type="html"><![CDATA[<p>明月几时有，把酒问青天。</p><p>不知天上宫阙，今夕是何年。</p><p>今日一别，三月后见。</p><p>他日在别，不知何时相见。</p>]]></content>
    
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计</title>
    <link href="/2021/12/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    <url>/2021/12/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<pre><code class=" mermaid">graph LR概率论与数理统计--&gt;概率论概率论与数理统计--&gt;数理统计概率论--高中知识--&gt;随机事件与概率随机事件与概率--&gt;几种概型随机事件与概率--&gt;全概率公式与贝叶斯公式随机事件与概率--&gt;独立性概率论--高等数学--&gt;一维随机变量及分布一维随机变量及分布--&gt;离散的几种分布一维随机变量及分布--&gt;连续的几种分布一维随机变量及分布--&gt;随机变量函数的分布概率论--高等数学--&gt;多维随机变量及分布多维随机变量及分布--&gt;二维离散和连续的随机变量多维随机变量及分布--&gt;边缘分布多维随机变量及分布--&gt;条件分布多维随机变量及分布--&gt;独立的随机变量多维随机变量及分布--&gt;两个变量的函数分布-.-&gt;和商积最大最小概率论--&gt;随机变量的数字特征-.-&gt;均值与方差概率论--&gt;大数定律和中心极限法则-.-&gt;两个大数定律两个中心极限定理数理统计--&gt;样本和抽样分布样本和抽样分布--&gt;三大抽样分布数理统计--&gt;参数估计参数估计--&gt;点估计--&gt;矩估计--&gt;评选准则点估计--&gt;最大似然估计--&gt;评选准则参数估计--&gt;区间估计--&gt;单侧置信区间数理统计--&gt;假设检验--&gt;选函数--&gt;拒绝域</code></pre><p>以上是对概率论与数理统计的知识体系的整理</p><p>让我们开始复习第一章吧（馆长笑）</p><h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h2 id="随机事件与概率"><a href="#随机事件与概率" class="headerlink" title="随机事件与概率"></a>随机事件与概率</h2><p> 随机事件就是由随机试验得出样本空间的子集。</p><p>频率：随机事件A发生的次数比上随机事件总数。记为$f_n(A)$, 满足非负性、规范性、可列可加性。</p><h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>等可能概型</p><p>4白2红球，从口袋中取两次，每次随机，求两只球都是白球的概率</p><p>放回抽样</p><p>$P= \frac {C_4^1*C_4^1}{6^2}$</p><p>不放回抽样</p><p>$P=\frac {C_4^2}{C_6^2}$</p><h3 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h3><p>落在某个空间中是等可能的</p><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>$P(A|B)=\frac {P(AB)}{P(A)}$ </p><p>乘法公式：P(AB)=$P(A) \times P(B|A)=P(B) \times P(A|B)$</p><p>推广到n维 $P(X_1X_2X_3…X_n)=P(X_1)P(X_2|X_1)P(X_3|X_1X_2)…P(X_n|X_1X_2X_3…X_{n-1})$</p><p>例题：<a href="https://zhuanlan.zhihu.com/p/418038748">抽签原理/条件概率/古典概型小例题 - 知乎 (zhihu.com)</a></p><p>设10件产品中有3件次品，7件正品，从中每次取一件，取后不放回，求下列事件的概率</p><ol><li>第三次取得次品的概率</li><li>第三次才取得次品的概率</li><li>已知前两次没有取得次品，第三次取得次品的概率</li></ol><p>第一题是很显然的抽签原理，当然也可以用<a href="https://www.zhihu.com/search?q=%E5%8F%A4%E5%85%B8%E6%A6%82%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:418038748%7D">古典概型</a>。</p><blockquote><p>抽签原理：假设有a红球，b白球，只要一次取一个，第k次取得红球概率与是否放回无关，与前后次序无关，只与球的个数有关，概率都为 $\frac {a} {a+b}$。因为在每一次抽签的时候，抽签的“人”应该是互相**<em>独立*<strong>的，不能开上帝视角</strong></em>预知其他次抽签的情况***。<br>古典概型：一个一个取就是按顺序就用$A_a^b$ （排列），两个及以上的取就用 $C_a^b$(组合)</p><ol><li><p>根据抽签原理：$P=\frac {3}{10}$</p></li><li><p>根据古典概型：<img src="https://www.zhihu.com/equation?tex=P=%5Cfrac%7B%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%8F%96%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%B8%BA%E6%AC%A1%E5%93%81*%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%8F%96%E5%89%8D%E4%B8%A4%E4%B8%AA%7D%7B%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%8F%96%E4%B8%89%E4%B8%AA%E6%AC%A1%E5%93%81%7D=%5Cfrac%7BA_%7B3%7D%5E%7B1%7D*A_%7B9%7D%5E%7B2%7D%7D%7BA_%7B10%7D%5E%7B3%7D%7D=%5Cfrac%7B3*9*8%7D%7B10*9*8%7D=%5Cfrac%7B3%7D%7B10%7D" alt="[公式]"></p></li><li><p>（2）第二题题目可以理解为：三次分别取 正品、正品、次品，可用<a href="https://www.zhihu.com/search?q=%E4%B9%98%E6%B3%95%E5%85%AC%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:418038748%7D">乘法公式</a>和古典概型。先设 <img src="https://www.zhihu.com/equation?tex=A_i" alt="[公式]"> ={第 i次取得次品}（乘法公式要用）。</p><ol><li>根据乘法公式： $P=\frac {A_3^2*A_9^2}{A_10^3}=3/10$</li><li>根据古典概型： <img src="https://www.zhihu.com/equation?tex=P=%5Cfrac%7B%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%8F%96%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%B8%BA%E6%AC%A1%E5%93%81*%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%8F%96%E5%89%8D%E4%B8%A4%E4%B8%AA%5Ccolor%7Bred%7D%7B%E4%B8%BA%E6%AD%A3%E5%93%81%7D%7D%7B%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%8F%96%E4%B8%89%E4%B8%AA%E6%AC%A1%E5%93%81%7D=%5Cfrac%7BA_%7B3%7D%5E%7B1%7D*%5Ccolor%7Bred%7D%7BA_%7B7%7D%5E%7B2%7D%7D%7D%7BA_%7B10%7D%5E%7B3%7D%7D=%5Cfrac%7B3*7*6%7D%7B10*9*8%7D=%5Cfrac%7B7%7D%7B40%7D" alt="[公式]">很显然，第二题的概率比第一题小，之所以会发生这种情况，是由于第二题的情况比第一题更严苛，从原来 *<strong>不知道其他次取法*</strong> 变为了 *<strong>我知道前两次取得是正品*</strong> 。</li></ol><p>（3）第三题就是典型<strong>条件概率</strong></p><p>​        $P(A_3|\bar{A_2}\bar{A_1})=3/8$</p><blockquote><p>这题的条件概率就是典型的开了***“上帝视角”***，由于我们知道其他次实验更多的信息，导致我们对第三次取次品的把握更大了，表现在 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B3%7D%7B8%7D%3E%5Cfrac%7B3%7D%7B10%7D" alt="[公式]"></p></blockquote></li></ol></blockquote><h3 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h3><p>由因到果</p><p><strong>完备事件组</strong>：所有事件加起来等于样本空间(B就是对样本空间的划分)</p><p><strong>全概率公式</strong>：$P(A)=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+…+P(A|B_n)P(B_n)$，这里B是完备事件组。</p><p>他就是在每一个划分区域里求该事件的概率，在求和，得到这个事件在整个样本空间的概率。</p><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>由果推因</p><p>$P(B_i|A)=\frac {P(B_i)P(A|B_i)} {\sum_{j=1}^n P(B_j)P(A|B_j)}$</p><p>他就是在某个事件中某一块划分的概率。</p><p>image<img src="/img/%E9%AB%98%E6%95%B0/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p><p><strong>梨米特的例题<a href="https://www.bilibili.com/video/BV1D741147G5?p=11">【梨米特】全网最适合大学生学习的《概率论与数理统计》课，概率统计知识点全解析（适合大一学习、考研复习基础）_哔哩哔哩_bilibili</a></strong></p><p>image<img src="/img/%E9%AB%98%E6%95%B0/%E5%85%A8%E8%B4%9D%E4%BE%8B%E9%A2%98.png"></p><h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>若事件A与B独立，则满足P(AB)=P(A)P(B)</p><p>也可得出P(A|B)=P(A)</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>概率论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>math</title>
    <link href="/2021/12/10/math/"/>
    <url>/2021/12/10/math/</url>
    
    <content type="html"><![CDATA[<h1 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h1><h2 id="等价无穷小"><a href="#等价无穷小" class="headerlink" title="等价无穷小"></a>等价无穷小</h2><p>image<img src="img/%E9%AB%98%E6%95%B0/%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F.jpg"></p><p>利用等价无穷小简化计算。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>交换排序</title>
    <link href="/2021/12/05/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/12/05/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="什么是交换排序"><a href="#什么是交换排序" class="headerlink" title="什么是交换排序"></a>什么是交换排序</h2><p>时时比较交换。</p><p>分类：冒泡排序，快速排序。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序就好比水里的气泡从底部逐渐冒出水面。</p><p>原理就是从前往后比较相邻两个数，若逆序就交换，直到一趟比完。最终（不看前面已经排好的）第一位一定是最值。倘若中间有不交换的一趟，就结束，证明已经排好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n<span class="hljs-number">-1</span>;j++)&#123;<br><span class="hljs-keyword">if</span>(A[j<span class="hljs-number">-1</span>]&gt;A[j])&#123;<br><span class="hljs-built_in">swap</span>(A[j<span class="hljs-number">-1</span>],A[j]);<br>              flag=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$</p><p>稳定性：稳定</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是基于分治。</p><p>严蔚敏版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">int</span> x=A[l];<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br><span class="hljs-keyword">while</span>(A[r]&gt;=x)r--;<br>        A[l]=A[r];<br>         <span class="hljs-keyword">while</span>(A[l]&lt;=x)l++;<br>        A[r]=A[l];<br>    &#125;<br>    A[l]=x;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">int</span> p=<span class="hljs-built_in">Partition</span>(A,l,r);<br>    <span class="hljs-built_in">sort</span>(A,l,p<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">sort</span>(A,p+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>ACwing版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">int</span> x=a[(l+r)&gt;&gt;<span class="hljs-number">1</span>],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(x&gt;a[i]);<br>         <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(x&lt;a[j]);<br>        <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">qsort</span>(a,l,j),<span class="hljs-built_in">qsort</span>(a,j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：$O(nlogn)$</p><p>稳定性：不稳定</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2021/12/05/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/12/05/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="什么是插入排序"><a href="#什么是插入排序" class="headerlink" title="什么是插入排序"></a>什么是插入排序</h2><p>插入排序就是将待排序的关键字按其关键字大小插入到前面已经排好的序列，直到所有关键字插入完毕。</p><p>插入排序有：直接插入排序，折半插入排序，希尔排序。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>先把前面排好序，然后后面的关键字与其前面的比大小，找到合适的位置，插入(其实是边比边后移)。</p><p>往往第一个元素我们当作已经有序，所以从第二个开始。</p><p>这里是排为从小到大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(ElemType A[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//第0个当哨兵，第1个已经有序了。</span><br><span class="hljs-keyword">if</span>(A[i]&lt;A[i<span class="hljs-number">-1</span>])&#123;<br>A[<span class="hljs-number">0</span>]=A[i];<br>             <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;A[<span class="hljs-number">0</span>]&lt;A[j];j--)&#123;<br>A[j+<span class="hljs-number">1</span>]=A[j];<br>             &#125;<br>            A[j+<span class="hljs-number">1</span>]=A[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>链表版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(SqList &amp;S)</span></span>&#123;<br><span class="hljs-keyword">for</span>(LNode *i=S-&gt;next;i;i=i-&gt;next)&#123;<br><span class="hljs-keyword">if</span>((i-&gt;data) &lt; (i-&gt;pir-&gt;data))&#123;<br><span class="hljs-keyword">int</span> x=i-&gt;data;<br>LNode *j;<br>i-&gt;pir-&gt;next=i-&gt;next;<br><span class="hljs-keyword">if</span>(i-&gt;next)i-&gt;next-&gt;pir=i-&gt;pir;<br><span class="hljs-keyword">for</span>(j=i-&gt;pir; j&amp;&amp;j-&gt;data&gt;i-&gt;data ;j = j-&gt;pir);<br><span class="hljs-keyword">if</span>(j==<span class="hljs-literal">NULL</span>)&#123;<br>SqList t=S;<br>S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>S-&gt;data=x;<br>S-&gt;next=t;<br>S-&gt;pir=<span class="hljs-literal">NULL</span>;<br>t-&gt;pir=S;<br>&#125; <br><span class="hljs-keyword">else</span>&#123;<br>SqList q=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>q-&gt;data=x;<br>q-&gt;next=j-&gt;next;<br>q-&gt;pir=j;<br>j-&gt;next-&gt;pir=q;<br>j-&gt;next=q;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考试会考排序过程的第几趟。</p><p>当顺序刚好是需要的顺序，进行n-1趟，每一趟又是比较1次。所以是O(n)。</p><p>当刚好逆序的时候，进行n-1趟，每一趟又是比较$i$次。所以是$O(n^2)$。</p><p>时间复杂度：$O(n^2)$</p><p>稳定性：稳定</p><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p>前面不是已经有序了吗，然后就用二分查找直接查出对应位置，减少查找时间复杂度。后移，插入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(ElemType A[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">int</span> i,j;<br>    <span class="hljs-keyword">int</span> r,l,mid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>l=<span class="hljs-number">1</span>,r=i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(A[i]&lt;A[i<span class="hljs-number">-1</span>])&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(A[mid]&lt;=A[<span class="hljs-number">0</span>])l=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=r+<span class="hljs-number">1</span>;j--)A[j+<span class="hljs-number">1</span>]=A[j];<br>            A[r+<span class="hljs-number">1</span>]=A[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个算法只是减少查找的时间，并没有减少移动的时间，也就是说最后时间复杂度还是$O(n^2)$。</p><p>稳定性：稳定。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>这个是真正减少了时间。</p><p>思想就是,上面的时间复杂度是顺序的时候小，我们就需要，要表逐渐的有一定的顺序。</p><p>方法是：第一次用n/2进行间隔插入排序，下一次是上一次数的一半。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,dk;<br><span class="hljs-keyword">for</span>(dk=n/<span class="hljs-number">2</span>;dk&gt;=<span class="hljs-number">1</span>;dk=dk&gt;&gt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//以下-dk操作，均可类比简单排的-1操作,每次比较的不再是前1个，而是前dk个</span><br><span class="hljs-keyword">for</span>(i=dk+<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(A[i]&lt;A[i-dk])&#123;<br>A[<span class="hljs-number">0</span>]=A[i];<br>                 <span class="hljs-keyword">for</span>(j=i-dk;j&gt;<span class="hljs-number">0</span>&amp;&amp;A[<span class="hljs-number">0</span>]&lt;A[j];j-=dk)&#123;<span class="hljs-comment">//j&gt;0是为了以免-dj小于0</span><br>A[j+dk]=A[j];<br>                 &#125;<br>                A[j+dk]=A[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度极为难算：约为$O(n^{1.3})$，最坏$O(n^{2})$</p><p>稳定性：不稳定</p><p>适用性：仅顺序存储</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度A+B</title>
    <link href="/2021/11/30/%E9%AB%98%E7%B2%BE%E5%BA%A6A+B/"/>
    <url>/2021/11/30/%E9%AB%98%E7%B2%BE%E5%BA%A6A+B/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度A-B"><a href="#高精度A-B" class="headerlink" title="高精度A+B"></a>高精度A+B</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>c语言int 最大是$2^{31}-1$，64位电脑下long 和long long 最大是 $2^{63}-1$。</p><p>于是我们再进行高精度计算时，如果数值超过$2^{63}-1$就无法存储了。</p><p>我们会想用double来计算，但浮点数是用二进制模拟的，不准确，有误差。</p><p>于是我们需要用一种更高精度的方式来计算高精度A+B。</p><h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><p>在小学，我们都学过加法运算吧。我们的方法就是模拟这个过程来计算，再将计算的数值存入一个无限长的表里。最终输出这个表，就是答案了。</p><p>先来看看小学的方式</p><p>image<img src="/img/%E7%AE%97%E6%B3%95/A+B.png" alt="A+B"></p><p>这个表选择vector作为容器。不会vector看这里<a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析 | 菜鸟教程 (runoob.com)</a></p><p>计算过程就是A的k位加B的k位，将位数的个位存入表，将十位存入t。</p><p>下一次，将A的k位加B的k位+t，将位数的个位存入表，将十位存入t。</p><p>直到，A或B都加到头。（已经到头的就不加入了比如B到头就是 A[k]+t）</p><p>最终，有进位的t就在表里加1，就结束了。</p><p>这就是小学计算加法的过程。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; A,vector&lt;<span class="hljs-keyword">int</span>&gt; B)</span></span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; C;<span class="hljs-comment">//结果</span><br>    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//位数相加的结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>())t+=A[i];<br>         <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>string a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; A,B,C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    C=<span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkList</title>
    <link href="/2021/11/29/LinkList/"/>
    <url>/2021/11/29/LinkList/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表是最简单的链式结构，也是一切的基础。</p><p>先来看看它的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br><span class="hljs-keyword">int</span> data;<span class="hljs-comment">//存的数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个节点的指针</span><br>&#125;LNode,*SqList;<br></code></pre></td></tr></table></figure><p>创建一个单链表有多种方法</p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>有头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FILO_H</span><span class="hljs-params">(SqList &amp;S,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>    S-&gt;next=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>SqList q=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q-&gt;data);<br>        q-&gt;next=S-&gt;next;<br>        S-&gt;next=q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FILO</span><span class="hljs-params">(SqList &amp;S,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>SqList q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(!i)&#123;<br>S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;S-&gt;data);<br>S-&gt;next=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>q=S;<br>S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;S-&gt;data);<br>S-&gt;next=q;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>有头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SqList <span class="hljs-title">FIFO_H</span><span class="hljs-params">(SqList &amp;q)</span></span>&#123;<br>SqList p;<br>p=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;data);<br>p-&gt;next=q-&gt;next;<br>q-&gt;next=p;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>无头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIFO</span><span class="hljs-params">(SqList &amp;S,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>SqList r,q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(!i)&#123;<br>S=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;S-&gt;data);<br>            S-&gt;next=<span class="hljs-literal">NULL</span>;<br>            r=S;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        q=(SqList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q-&gt;data);<br>        q-&gt;next=r-&gt;next;<br>        r-&gt;next=q;<br>        r=r-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链式结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HushTable</title>
    <link href="/2021/11/26/HushTable/"/>
    <url>/2021/11/26/HushTable/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表是用来做什么的？"><a href="#哈希表是用来做什么的？" class="headerlink" title="哈希表是用来做什么的？"></a>哈希表是用来做什么的？</h2><p>​    以平均常数时间对关键字进行查找、删除、插入。</p><p>​    hash表是为了以最快的时间查找到内容，同时保证空间利用的高效，可以说是和珅最爱了。</p><p>​    就好比一个3个字母的英语单词我们可以把它看成一个三维空间的点，然后我们把他表示成一个数的方式是从（0，0，0）标记成0，（25,25,25）标记成$26\times 26\times 26$。然后中间的某一单词就是$26^2 \times x+26\times y+z $，对于更长的单词是更高次幂的多项式表示。</p><p>这种方式查找是快了，但对空间的浪费很大。常用的单词并没有这么多。</p><p>哈希通过散列函数将关键字<strong>x</strong> (可以是任意值)映射为<strong>y</strong> (某一地址)。好的散列函数既要保证空间利用的高效，又要照顾查找的快慢。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="如何选择散列函数"><a href="#如何选择散列函数" class="headerlink" title="如何选择散列函数"></a>如何选择散列函数</h3><ol><li>直接地址法：H(key)=key, H(key)=$a \times key+b$</li><li>除留余数法：H(key)=key%p</li><li>数字分析法：找数字段中在散列表中可以分布均匀的的地方</li><li>平方取中法：取平方值的中间几位作为散列地址</li></ol><p>我们主要讨论除留取余法。</p><p>​    字符串处理方法：</p><ol><li><p>$\sum_{i=0}^nASCII(key[i])\mod p$</p></li><li><p>将字符串长度看成维度扁平化为一维数字，然后将扁平化后的数字mod p</p><p>扁平化就像<em>哈希表是用来做什么的？</em>里面所说的那样。</p></li><li><p>将2.的扁平化用秦九韶算法优化，将乘法变为左移提高速度。</p></li></ol><h3 id="哈希函数产生的冲突"><a href="#哈希函数产生的冲突" class="headerlink" title="哈希函数产生的冲突"></a>哈希函数产生的冲突</h3><p>​    不同数字之间的余数可能会相同，不同字符串的字符值求和也可能相同，种种原因等导致最后哈希函数计算出的哈希地址相同，这种情况称为冲突。</p><p>冲突是哈希函数尽量避免而又避免不了的，那么我们又将如何处理和减少冲突呢。</p><ol><li><p>选择合适的素数为哈希表大小，减少冲突</p></li><li><p>用合适的方法处理，处理冲突</p><ol><li><p>分离链式法：将重复的值在同一单链表中。</p><p>优点：表长短，省空间。</p><p>缺点：查找时时间会随着链表长度加长而加长。</p></li><li><p>开放地址法：</p><p>$h_i(key)=(Hash(key)+F(i)) \mod p $</p><p>冲突后就将地址用F（i）偏移到其他地方，i 代表偏移次数。</p><p>以下是常用的偏移方法</p><p>方法一：线性探测法</p><p>​    F(i)=i</p><p>​    优点：操作简单</p><p>​    缺点：这样容易形成一次聚集区块，导致查找时间变长。</p><p>改进：$F(i)=(-1)^i \times i $</p><p>方法二：平方探测法（二次探测）</p><p>​    $F(i)=(-1)^{i}\times i^2$，k&lt;=m/2，散列表长度m必须是一个可以表示成$4\times k+3$的素数，称为二次探测法。</p><p>​    避免了堆积，但不能用上所有单元，但至少能探测到一半单元。</p><p>​    优点：一定程度上避免了聚集</p><p>​    缺点：表的空间利用率不高</p><p>方法三：再散列</p><p>再散列有普通版和优化版。</p><ol><li>普通版就是当第一个hash函数冲突时用第二个hash函数，第二个冲突用第三个hash函数，直到地址不冲突为止。</li></ol><p>​    经过表长次回到原点</p><p>​    普通版解决冲突问题的能力是有限的，一旦表很满时（填充因子就很大），找不冲突就很难，再散列的次数就越多。</p><ol start="2"><li><p>优化版当元素太满时，找一个新空间，表长是上一次表长2倍后的第一个素数。将原表插入到新表。</p><p>优点：聚集减少了，也不用担心表长不够</p><p>缺点：建立新表费时间</p></li></ol></li></ol><h2 id="分离链式法"><a href="#分离链式法" class="headerlink" title="分离链式法"></a>分离链式法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_SIZE=<span class="hljs-number">1001</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span>&#123;</span><br><span class="hljs-keyword">int</span> data;<br><span class="hljs-keyword">bool</span> flag;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;HNode,*Node;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>HNode eles[MAX_SIZE];<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">int</span> MAX_NUM;<br>&#125;HushTable;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitHushTable</span><span class="hljs-params">(HushTable &amp;H,<span class="hljs-keyword">int</span> m)</span></span>&#123;<br>H.MAX_NUM=m;<br>H.num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;H.MAX_NUM;i++) H.eles[i].flag=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;H.MAX_NUM;i++) H.eles[i].next=<span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(HushTable &amp;H,<span class="hljs-keyword">int</span> ele)</span></span>&#123;<br><span class="hljs-comment">//头插法 </span><br>HNode *q=(Node)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(HNode));<br>q-&gt;data=ele;<br>q-&gt;flag=<span class="hljs-literal">true</span>;<br>q-&gt;next=H.eles[ele%(H.MAX_NUM)].next;<br><span class="hljs-comment">//取模插入 </span><br>H.eles[ele%(H.MAX_NUM)].next=q;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-keyword">int</span> *eles;<br><span class="hljs-keyword">bool</span> *flag;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">int</span> TableSize;<br>&#125;hushtable;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateHushTable</span><span class="hljs-params">(hushtable &amp;H)</span></span>&#123;<br>H.eles=(<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">53</span>);<br>H.flag=(<span class="hljs-keyword">bool</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">bool</span>)*<span class="hljs-number">53</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">53</span>;i++)H.flag[i]=<span class="hljs-literal">false</span>;<br>H.num=<span class="hljs-number">0</span>;<br>H.TableSize=<span class="hljs-number">53</span>;<br>&#125;<br><span class="hljs-comment">//我写的版</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hush</span><span class="hljs-params">(hushtable &amp;H,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;H.TableSize;i++)&#123;<br><span class="hljs-keyword">if</span>(!H.flag[(x+i)%H.TableSize])<span class="hljs-keyword">return</span> (x+i)%H.TableSize;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//AcWing版</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(hushtable &amp;H,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> N=H.TableSize;<br>    <span class="hljs-keyword">int</span> t=(x%N+N)%N;<br>    <span class="hljs-keyword">while</span>(!(!H.flag[t]||H.eles[t]==x))&#123;<br>        t=(t+<span class="hljs-number">1</span>)%N;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add</span><span class="hljs-params">(hushtable &amp;H,<span class="hljs-keyword">int</span> ele)</span></span>&#123;<br><span class="hljs-keyword">if</span>(H.TableSize==H.num)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">int</span> t=<span class="hljs-built_in">hush</span>(H,ele);<br>H.eles[t]=ele;<br>H.flag[t]=<span class="hljs-literal">true</span>;<br>H.num++;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>AcWing 的时间更少，我的在测试时会有样例超时。</p><h2 id="平方探测"><a href="#平方探测" class="headerlink" title="平方探测"></a>平方探测</h2><p>和线性探测一样，就是换个函数。</p><h3 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h3><p>我们这里直接使用优化版再散列函数。</p><p>衡量是否太满的值是填装因子，可以自己调节。</p><p>插入时可用线性或平方探测。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Rehush</span><span class="hljs-params">(hushtable &amp;H,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br> <span class="hljs-keyword">int</span> N=H.TableSize;<br> <span class="hljs-keyword">double</span> a=(H.num*<span class="hljs-number">1.0</span>)/H.TableSize;<br> <span class="hljs-comment">//填装因子判定 </span><br> <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0.5</span>)&#123;<br> <span class="hljs-keyword">int</span> new_TableSize=<span class="hljs-built_in">Find_Prime_Number</span>(H.TableSize);<br> hushtable newH;<br> <span class="hljs-built_in">InitHushTable</span>(newH,new_TableSize);<br> <span class="hljs-comment">//导入新空间 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;H.TableSize;i++)&#123;<br><span class="hljs-keyword">if</span>(H.flag[i])<span class="hljs-built_in">Insert</span>(newH,H.eles[i]);<br>&#125;<br><span class="hljs-comment">//释放就的空间，将新的copy到旧的名字。 </span><br><span class="hljs-built_in">free</span>(H.eles);<br><span class="hljs-built_in">free</span>(H.flag);<br>H.eles=newH.eles;<br>H.flag=newH.flag;<br>H.num=newH.num;<br>H.TableSize=newH.TableSize;<br> &#125;<br> <span class="hljs-built_in">Insert</span>(H,x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>处理字符串的哈希方式，有比kmp更强大的查重效率</p><p>思想:</p><ol><li>哈希</li><li>前缀和</li><li>类比十进制求各个位数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ULL;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000010</span>;<br><span class="hljs-comment">//h[]是前缀所有的哈希值，p[]是P的次方</span><br>ULL h[<span class="hljs-number">100010</span>],p[<span class="hljs-number">100010</span>],P=<span class="hljs-number">131</span>;<br><span class="hljs-comment">//求哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">char</span> str[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//p的0次方是1</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,str+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>p[i]=p[i<span class="hljs-number">-1</span>]*P;<br>        h[i]=h[i<span class="hljs-number">-1</span>]*P+str[i];<br>    &#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-keyword">int</span> l1,l2,r1,r2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l1,r1)==<span class="hljs-built_in">get</span>(l2,r2))<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//技巧是unsigned long long 可以自主取模2^64</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>graph2</title>
    <link href="/2021/11/25/graph2/"/>
    <url>/2021/11/25/graph2/</url>
    
    <content type="html"><![CDATA[<h1 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h1><h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>​    生成树：一个连通图的生成树是一个极小的连通子图，它包含图中全部的n个顶点，但只有构成一棵    树的n-1条边。</p><p>​    最小生成树：就是原图中<strong>边的权值的和最小的生成树</strong> ，所谓最小是指边的权值之和小于或者等于其它生成树的边的权值之和。</p><ol><li><p><strong>prim</strong></p><p>Prim算法针对的是连通网（连通带权图）的最小生成树。每次都要从不在集合中选这一个距离集合最近的点，直到所有节点都被选入集合。</p><p><em><strong>*这里面最特殊的就是被选入的第一个点，初始的距离都是无穷，所以随便选取一个点就可以，而t==-1这个判断条件使得0号元素可以选中，也就固定的每次从数组0号开始生成最小生成树*</strong></em></p><p>邻接矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(MGraph &amp;G,ALGraph &amp;Tree)</span></span>&#123;<span class="hljs-comment">//树可以是个图，他是无向有权图</span><br>Tree.vexnum=G.vexnum;<br>Tree.arcnum=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//dist是一个用来表示该点到集合内任一点中最小的距离 </span><br><span class="hljs-keyword">int</span> dist[MAX_VERTEX_NUM];<br><span class="hljs-comment">//初始化为无穷</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAX_VERTEX_NUM;i++)dist[i]=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-comment">//flag在这里表示是否进入集合</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++) G.flag[i]=<span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//开始生成树 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-comment">//一个指针，指向距离集合最小点的下标。</span><br><span class="hljs-keyword">int</span> t=<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//找到路径最小的点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;j++)&#123;<br><span class="hljs-keyword">if</span>(!G.flag[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))t=j;<br>&#125;<br>G.flag[t]=<span class="hljs-literal">true</span>;<br><span class="hljs-comment">//第i个点不是第一个（后面没更新），其余如果最小距离集合的点是无穷大，就说明网不连通 </span><br><span class="hljs-keyword">if</span>(i&amp;&amp;dist[t]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//建树</span><br><span class="hljs-keyword">if</span>(i)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++)&#123;<br><span class="hljs-comment">//如果k-&gt;t是这条最短边，就将这两个点在树里链接</span><br><span class="hljs-keyword">if</span>(G.arcs[k][t].adj==dist[t])&#123;<br><span class="hljs-built_in">add</span>(Tree,k,t,G.vexs[k],G.vexs[t],dist[t]);<br>&#125;<br>&#125;<br><span class="hljs-comment">//更新，用最小那个点来更新最短距集合的距离。 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;j++)dist[j]=<span class="hljs-built_in">Min</span>(dist[j],G.arcs[t][j].adj);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>树是包含于图的，它是一个无向图，可以用邻接表的方式表示，创建树也是会创建无向图的过程</p></li><li><p><strong>Kruskal</strong></p><p>​    Kruskal针对连通无向有权图求最小生成树，先对边进行排序，每次选择最小的边，看两个点是否为一个集合内，如果是就不连接，不是就将这条边连接。</p><p>AcWing 版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> p[<span class="hljs-number">100010</span>];<br><span class="hljs-comment">//结构体是边</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edg</span>&#123;</span><br>    <span class="hljs-comment">//a,b是边连接的两个点，w是权重</span><br>    <span class="hljs-keyword">int</span> a,b,w;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> edg &amp;W)<span class="hljs-keyword">const</span>&#123;<span class="hljs-comment">//重载小于号</span><br>        <span class="hljs-keyword">return</span> w&lt;W.w;<br>    &#125;<br>&#125;edgs[<span class="hljs-number">200010</span>];<br><span class="hljs-comment">//并查集查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x!=p[x])p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a,b,w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);<br>        edgs[i].a=a;<br>        edgs[i].b=b;<br>        edgs[i].w=w;<br>        <span class="hljs-comment">//edgs[i]=&#123;a,b,w&#125;;</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(edgs,edgs+m);<span class="hljs-comment">//重载是为了比较的时候&lt;号直接比较的是结构体中的w.</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)p[i]=i;<span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a=edgs[i].a,b=edgs[i].b,w=edgs[i].w;<span class="hljs-comment">//权重为w</span><br>        a=<span class="hljs-built_in">find</span>(a),b=<span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            p[a]=b;<br>            res+=edgs[i].w;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt&lt;n<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);<span class="hljs-comment">//一共选n-1条边就是生成树，小于就不连通</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ol><li><p><strong>Dijkstra</strong></p><p>和prim最小生成树极为相似，区别在于更新时，这里是点1到点j的最短路,而prim是集合到点j的最短</p><p>每一个较短路都是通过以确定的最短路加上终点到对应点的距离比较得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-comment">//n是点数，m是边数</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-comment">//g是邻接矩阵，dist是到1点的最短距离，st是是否确定最短路的状态</span><br><span class="hljs-keyword">int</span> g[N][N],dist[N],st[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dist));<span class="hljs-comment">//int 站四个字节，四个字节都是3f，作为无穷大</span><br>    <span class="hljs-comment">//初始化，1到1的距离是0</span><br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">//t记录最短路的终点</span><br>        <span class="hljs-keyword">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//找出最短的终点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))&#123;<br>                t=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将他的最短状态确定</span><br>        st[t]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//有这条最短更新其他结点最短路</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这个题是让返回1到n的最短路</span><br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//3f3f3f3f才是int最大</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>Dijkstra还可以用堆优化</p></li><li><p><strong>Floyd</strong></p><p>本质是用动态规划求解最短路</p><p>由前面可达的点的最短路得到该点最短路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> d[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br><span class="hljs-keyword">int</span> n,m,k;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[k][j]+d[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)d[i][i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//自己到自己最短是0，题里有自环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a,b,w;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>        d[a][b]=<span class="hljs-built_in">min</span>(w,d[a][b]);<span class="hljs-comment">//题里有重边</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(d[a][b]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//题里有负权边</span><br>        <span class="hljs-keyword">else</span> cout&lt;&lt;d[a][b]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序针对的是AOV网，他必须有向，有权值，无环</p><p>排列出工作完成的先后合理顺序</p><p>思想基础是bfs</p><p>最后这个队列中装上所有的结点就证明无环。若是有环就一定有节点入读无法减为零。这个刻意判定环的存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拓扑排序（邻接表） </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TopSort</span><span class="hljs-params">(ALGraph &amp;G,<span class="hljs-keyword">int</span> **ans)</span></span>&#123;<br><span class="hljs-comment">//初始化标志 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++) G.vertices[k].flag=<span class="hljs-literal">false</span>;<br><span class="hljs-comment">//以bfs为基础框架 </span><br>queue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-comment">//先遍历一遍所有节点，将所有入度为0的点装入队列中</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.vertices[i].in_degree==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">push</span>(Q,i);<br>G.vertices[i].flag=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//队列不为空，就出度。 </span><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-comment">//遍历出度所连接的点，将其入度减一。</span><br><span class="hljs-keyword">for</span>(ArcNode *q=G.vertices[e].firstarc;q;q=q-&gt;nextarc)&#123;<br><span class="hljs-keyword">int</span> j=q-&gt;adjvex;<br><span class="hljs-keyword">if</span>(G.vertices[j].flag)<span class="hljs-keyword">continue</span>;<br>G.vertices[j].in_degree--;<br><span class="hljs-comment">//入度为空入队列 </span><br><span class="hljs-keyword">if</span>(G.vertices[j].in_degree==<span class="hljs-number">0</span>)&#123;<br> G.vertices[j].flag=<span class="hljs-literal">true</span>;<br><span class="hljs-built_in">push</span>(Q,j);<br>&#125; <br>&#125;<br>&#125;<br>*ans=Q.ele;<br><span class="hljs-keyword">return</span> Q.r==G.vexnum;<span class="hljs-comment">//队列中的记录过结点总数个点说明它遍历完了，没有环。否则，有环。 </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拓扑排序（邻接矩阵） </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TopSort</span><span class="hljs-params">(MGraph &amp;G,<span class="hljs-keyword">int</span> **ans)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++) G.flag[i]=<span class="hljs-literal">false</span>;<br><br>queue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.in_degree[i]==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">push</span>(Q,i);<br>G.flag[i]=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.flag[i])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(G.arcs[e][i].adj==<span class="hljs-number">1</span>)&#123;<br>G.in_degree[i]--;<br><span class="hljs-keyword">if</span>(G.in_degree[i]==<span class="hljs-number">0</span>)&#123;<br>G.flag[i]=<span class="hljs-literal">true</span>;<br><span class="hljs-built_in">push</span>(Q,i);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>*ans=Q.ele;<br><span class="hljs-keyword">return</span> Q.r==G.vexnum;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p><em><strong>*关键路径的关键之处是要保证在整个任务完成的前提下进行。*</strong></em></p><p><em><strong>*里面所说的最大和最小都是在所有前提事件、活动都可以完成的情况下来讨论的，活动可以并发进行（多线程）*</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CriticalPath</span><span class="hljs-params">(MGraph &amp;G)</span></span>&#123;<span class="hljs-comment">//要保证在任务可完成的前提下 </span><br><span class="hljs-comment">//vl事件发生的最晚时间，ve事件发生的最早时间 </span><br><span class="hljs-keyword">int</span> vl[G.vexnum],ve[G.vexnum];<br><span class="hljs-comment">//求最小寻最大，初始化为0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)ve[i]=<span class="hljs-number">0</span>; <br><span class="hljs-comment">//求最大寻最小，初始化为无穷大</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)vl[i]=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">//拓扑排序（邻接矩阵） 求事件最早</span><br><span class="hljs-comment">//初始化标志 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++) G.flag[i]=<span class="hljs-literal">false</span>;<br>queue Q;<br>stack S;<span class="hljs-comment">//拓扑排序的逆序</span><br><span class="hljs-built_in">InitStack</span>(S);<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-comment">//先遍历一遍所有节点，将所有入度为0的点装入队列中</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.in_degree[i]==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">push</span>(Q,i);<br><span class="hljs-built_in">PUSH</span>(S,i);<br>G.flag[i]=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//队列不为空，就出度。</span><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-comment">//遍历出度所连接的点，将其入度减一。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">if</span>(G.flag[i])<span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//时间不是无穷说明有边 </span><br><span class="hljs-keyword">if</span>(G.arcs[e][i].adj!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br>G.in_degree[i]--;<br><span class="hljs-comment">//将事件的较早开始时间计算出来</span><br>ve[i]=<span class="hljs-built_in">Max</span>(ve[i],ve[e]+G.arcs[e][i].adj);<span class="hljs-comment">//</span><br><span class="hljs-comment">//入度为空入队列 </span><br><span class="hljs-keyword">if</span>(G.in_degree[i]==<span class="hljs-number">0</span>)&#123;<br>G.flag[i]=<span class="hljs-literal">true</span>;<br><span class="hljs-built_in">push</span>(Q,i);<br><span class="hljs-built_in">PUSH</span>(S,i);<span class="hljs-comment">//逆序 </span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//逆拓扑排序，入度信息已丢失,用栈来代替 求事件最晚 </span><br><span class="hljs-comment">//栈顶是最后一个事件 </span><br><span class="hljs-keyword">int</span> top=<span class="hljs-built_in">GetTop</span>(S);<br><span class="hljs-comment">//他的最早就是最晚 </span><br>vl[top]=ve[top]; <br><span class="hljs-comment">//栈不空出栈 </span><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(S))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">POP</span>(S,e);<br><span class="hljs-comment">//将所有和当前点有边的点计算较晚的值 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><br><span class="hljs-keyword">if</span>(G.arcs[i][e].adj!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br>vl[i]=<span class="hljs-built_in">Min</span>(vl[i],vl[e]-G.arcs[i][e].adj);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br> <span class="hljs-comment">/*这里的边是用两个点（数）表示的，而活动的早晚信息使用一个数表示活动，要将二维映射成一维，建立一一对应的关系。边的最大数值是点数的两两组合数。*/</span><br><span class="hljs-comment">//求活动开始与结束的最早和最晚</span><br><span class="hljs-keyword">int</span> e[MAX_ARC_NUM],l[MAX_ARC_NUM];<span class="hljs-comment">//MAX_ARC_NUM是C_(n-1)&#123;2&#125;算出来的 </span><br><span class="hljs-comment">//不可能是相同负值所以初始化为不同负值 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAX_ARC_NUM;i++)e[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAX_ARC_NUM;i++)l[i]=<span class="hljs-number">-2</span>;<br><span class="hljs-comment">//由点到边要对应(i*10+j)(i*4+j)</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;G.vexnum;j++)&#123;<br><span class="hljs-keyword">if</span>(G.arcs[i][j].adj!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br><span class="hljs-comment">//二位坐标映射为一维坐标 </span><br><span class="hljs-keyword">int</span> k=i*<span class="hljs-number">4</span>+j;<br>e[k]=ve[i];<br>l[k]=vl[j]-G.arcs[i][j].adj;<br><span class="hljs-comment">//最早和最晚相同就说明不能拖延,是关键路径上的边 </span><br><span class="hljs-keyword">if</span>(e[k]==l[k])<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d--%d &quot;</span>,G.vexs[i],G.vexs[j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>image<img src="/img/graph/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.jpg" alt="关键路径"></p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>graph</title>
    <link href="/2021/11/22/graph/"/>
    <url>/2021/11/22/graph/</url>
    
    <content type="html"><![CDATA[<h1 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h1><pre><code class=" mermaid">graph LR图--&gt;图的定义图--&gt;图的存储结构--&gt;邻接表--&gt;稀疏图图的存储结构--&gt;邻接矩阵--&gt;稠密图图的存储结构--&gt;十字链表图--&gt;图的遍历图的遍历--&gt;深度优先遍历dfs图的遍历--&gt;广度优先遍历bfs图--&gt;图的应用图的应用--&gt;最小生成树--&gt;prim最小生成树--&gt;Kruskal图的应用--&gt;最短路径最短路径--&gt;Dijkstra最短路径--&gt;Floyd图的应用--&gt;拓扑排序--&gt;逆拓扑排序图的应用--&gt;关键路径</code></pre><h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><p>图是由顶点的有穷非空集合和顶点之间边的集合组成， 通常表示为: G（V，E）， 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。$|V|$表示点的个数，$|E|$表示边的个数。</p><p>注意：树可以是空树，线性表可以是空表，图不可以为空图。</p><p>图的种类：(无向图、有向图、无向网、有向网)，(简单图，多重图)，(完全图)，(子图)，(稠密图、稀疏图)。</p><p>##图的存储结构</p><ol><li><p>邻接表：用来存稀疏图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MaxVerNum=<span class="hljs-number">100</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>&#123;</span><br>    <span class="hljs-comment">//弧指向顶点的位置</span><br><span class="hljs-keyword">int</span> adjvex;<br>    <span class="hljs-comment">//指向下一个弧的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">//弧的信息，例如权值</span><br>    <span class="hljs-comment">//InfoType info;</span><br>&#125;ArcNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span>&#123;</span><br>    <span class="hljs-comment">//顶点信息</span><br>    VertexType data;<br>    <span class="hljs-comment">//第一个弧</span><br>    ArcNode *firstarc;<br>&#125;VNode,AdjList[MaxVerNum];<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-comment">//邻接表(结点数组)</span><br>    AdjList vertices;<br>    <span class="hljs-keyword">int</span> vexnum,arcnum;<br>&#125;ALGraph;<br></code></pre></td></tr></table></figure></li><li><p>邻接矩阵：用来存稠密图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcCell</span>&#123;</span><br>    <span class="hljs-keyword">int</span> adj;<br>    <span class="hljs-comment">//节点其他信息</span><br>    <span class="hljs-comment">//InfoType *info;</span><br>&#125;ArcCell,AdjMatrix[MaxVerNum][MaxVerNum];<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-keyword">int</span> vexs[MaxVerNum];<br>    AdjMatrix arcs;<br>    <span class="hljs-keyword">int</span> vexnum,arcnum;<br>    <span class="hljs-comment">//int in_degree[MaxVerNum];</span><br>    <span class="hljs-comment">//bool flag[MaxVerNum];</span><br>&#125;ALGraph;<br></code></pre></td></tr></table></figure><p>创建无向边，就是创建有向边正反两遍。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>与树的层序遍历相似，用到了队列。</p><ol><li><p>从某一v结点开始访问</p></li><li><p>记录v的所有相邻节点</p></li><li><p>只要没访问过，从相邻结点队列中出一个从1开始。</p></li><li><p>直到图中点都被访问</p><p><em><strong>*类似于树的bfs遍历，区别是有重复，所以要flag标记。*</strong></em></p><p>邻接表的bfs：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(ALGraph &amp;G,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//初始化标志信息 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++) G.vertices[k].flag=<span class="hljs-literal">false</span>;<br><span class="hljs-comment">//用到了队列 </span><br>queue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-built_in">push</span>(Q,i);<br><span class="hljs-comment">//做标记 </span><br>G.vertices[i].flag=<span class="hljs-literal">true</span>;<br><span class="hljs-comment">//队不空出队 访问 </span><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,G.vertices[e].data);<br><span class="hljs-comment">//将出队元素的相邻元素入队</span><br><span class="hljs-keyword">for</span>(ArcNode *q=G.vertices[e].firstarc;q;q=q-&gt;nextarc)&#123;<br><span class="hljs-keyword">if</span>(G.vertices[q-&gt;adjvex].flag)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">push</span>(Q,q-&gt;adjvex);<br>G.vertices[q-&gt;adjvex].flag=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>邻接矩阵bfs：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(MGraph &amp;G,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++) G.flag[k]=<span class="hljs-number">0</span>;<br>queue Q;<br><span class="hljs-built_in">InitQueue</span>(Q);<br><span class="hljs-built_in">push</span>(Q,i);<br>G.flag[i]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br><span class="hljs-keyword">int</span> e;<br><span class="hljs-built_in">pop</span>(Q,e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,G.vexs[e]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++)&#123;<br><span class="hljs-keyword">if</span>(G.flag[k])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(G.arcs[e][k].adj!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<span class="hljs-comment">//无穷代表不连接</span><br><span class="hljs-built_in">push</span>(Q,k);<br>G.flag[k]=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><ol><li>从某一结点v开始访问</li><li>访问v的某一相邻结点（没被访问过）</li><li>重复，直到不能再访问</li></ol><p><em><strong>*类似于树的dfs遍历，区别是有重复，所以要flag标记。*</strong></em></p><p>邻接表的dfs (递归)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ALGraph &amp;G,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//出口：该节点已被访问过。 </span><br><span class="hljs-keyword">if</span>(G.vertices[i].flag)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//访问结点 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,G.vertices[i].data);<br><span class="hljs-comment">//标记已访问 </span><br>G.vertices[i].flag=<span class="hljs-literal">true</span>;<br><span class="hljs-comment">//遍历当前结点的所有相邻的结点依次dfs遍历 </span><br><span class="hljs-keyword">for</span>(ArcNode *q=G.vertices[i].firstarc;q;q=q-&gt;nextarc)&#123;<br><span class="hljs-built_in">dfs</span>(G,q-&gt;adjvex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>邻接矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(MGraph &amp;G,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">if</span>(G.flag[i])<span class="hljs-keyword">return</span>; <span class="hljs-comment">//exit</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,G.vexs[i]);<br>G.flag[i]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;G.vexnum;k++)&#123;<br><span class="hljs-keyword">if</span>(G.arcs[i][k].adj!=<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-built_in">dfs</span>(G,k);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的特征"><a href="#图的特征" class="headerlink" title="图的特征"></a>图的特征</h2><ol><li>$TD(v)=ID(v)+OD(v)$</li><li>$\sum_{i=1}^n TD(v_i)=2*e$ ,TD是vi的度</li><li>$ID(v)=OD(v)=e$</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HuffmanTree</title>
    <link href="/2021/10/31/HuffmanTree/"/>
    <url>/2021/10/31/HuffmanTree/</url>
    
    <content type="html"><![CDATA[<h1 id="HuffmanTree"><a href="#HuffmanTree" class="headerlink" title="HuffmanTree"></a>HuffmanTree</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有n个学生去考试，分数分为ABCDF四个等级，当我们用程序去分类时，分类代码是这样写的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">seperate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span></span>&#123;<br><span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">90</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">80</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">70</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&gt;=<span class="hljs-number">60</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;F&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是万金油的方法，但如果我的学生都不及格（开个玩笑），一共要进行n*4次判断才可以完成。</p><p>于是代码写成这样才是最优</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">seperate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span></span>&#123;<br><span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">60</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;F&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">70</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">80</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">90</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样我的学生都考满分，这又是效率最差的方法。</p><p>为了追求效率我们不能将问题细分到每一种情况去考虑。</p><p>那么有没有一种可以使得所有情况都较为高效的方法来解决这种分类问题呢，将这些数据进行一个压缩。</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>首先要知道的是我们要让数量最多的类别进行最少次数的判断。这种思想类似于概率论，种类的数量比作频率p，种类的判断次数比作变量x，我们要做的就是使均值($\sum_{i=1}^{n}{x_i*p_i}$)达到最小。</p><p>而且我们还要保证这些编码互相不能成为前缀，也就是译码（解压）时不可以出现歧义。</p><p>那么找一种什么结构来存呢，我们会想到的是用二叉树来存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-keyword">int</span> weight;<br><span class="hljs-keyword">int</span> lchild,rchild,parent;<br>&#125;*HuffmanTree,HTNode;<br></code></pre></td></tr></table></figure><p>离散数学里学过树是可以有权重的。那么这个权重就可以表示数量等一些信息的重要性。越重要的信息编码量就越小，这样就可以保证最后的信息总量被压缩。</p><p>其编码就是用二叉树的左边和右边来区分（这样就形成了一颗tire树），信息放在叶子节点，从根到叶子的路径就是他的编码。</p><p>我们要做的就是将权值大的信息放离树根近的地方。</p><p>image<img src="/img/tree/5.png" alt="哈夫曼树"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> **HuffmanCode; <br></code></pre></td></tr></table></figure><p><strong>编写哈夫曼树代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HuffmanCoding</span><span class="hljs-params">(HuffmanTree &amp;HT,HuffmanCode &amp;HC,<span class="hljs-keyword">int</span> *w,<span class="hljs-keyword">int</span> n)</span></span>&#123; <br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//计算节点总数</span><br><span class="hljs-keyword">int</span> m=n*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br><span class="hljs-comment">//初始化哈夫曼树</span><br>HT = (HuffmanTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HTNode)*(m+<span class="hljs-number">1</span>));<span class="hljs-comment">//严奶奶不喜欢用第0个 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//方便我自己写的，所以改了一下 </span><br>flag[i]=<span class="hljs-literal">true</span>;<br>HT[i].parent=<span class="hljs-number">0</span>;<br>HT[i].lchild=<span class="hljs-number">0</span>;<br>HT[i].rchild=<span class="hljs-number">0</span>;<br>&#125;<br>HT-&gt;n=n;<br><span class="hljs-comment">//工作指针</span><br>HuffmanTree p;<br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">for</span>(p=HT,i=<span class="hljs-number">1</span>;i&lt;=n;i++)p[i].weight=w[i];<br><span class="hljs-keyword">for</span>(;i&lt;=m;++i)p[i].weight=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=n+<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">int</span> s1,s2;<br>Select(HT,i<span class="hljs-number">-1</span>,s1,s2);<br>HT[s1].parent=i;<br>HT[s2].parent=i;<br>HT[i].lchild=s1;<br>HT[i].rchild=s2;<br>HT[i].weight=HT[s1].weight+HT[s2].weight;<br>&#125;<br><br><span class="hljs-comment">//编码 </span><br>HC = (HuffmanCode)<span class="hljs-built_in">malloc</span>((n+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>*));<br><span class="hljs-keyword">char</span>* cd = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br>cd[n<span class="hljs-number">-1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//经计算最大n-1个 ：注1</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> start = n<span class="hljs-number">-1</span>;<span class="hljs-comment">//严奶奶倒着存的 ：注2</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c=i,f=HT[i].parent;f!=<span class="hljs-number">0</span>;c=f,f=HT[f].parent)&#123;<br><span class="hljs-keyword">if</span>(HT[f].lchild==c)cd[--start]=<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">else</span> cd[--start]=<span class="hljs-string">&#x27;1&#x27;</span>;<br>&#125;<br>HC[i] = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>((n-start)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));<br><span class="hljs-built_in">strcpy</span>(HC[i],&amp;cd[start]);<span class="hljs-comment">//严奶奶截取的刚刚好 ：注2</span><br>&#125;<br><span class="hljs-built_in">free</span>(cd);<br>&#125;<br></code></pre></td></tr></table></figure><p>注1：n-1是最大的编码长度，树长成这样：image<img src="/img/tree/7.png"></p><p>注2：从n-1开始存储，下一个是n-2，最后一个的位置就是 strat。</p><p><strong>选择函数代码</strong></p><p>严奶奶书上写的方法就是最好的理解的，这里是书上的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HuffmanTree &amp;HT,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> &amp;s1,<span class="hljs-keyword">int</span> &amp;s2)</span></span>&#123;<br>HT[<span class="hljs-number">0</span>].weight=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">32</span><span class="hljs-number">-1</span>; <br>s1=<span class="hljs-number">0</span>;<br>s2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(HT[s1].weight!=<span class="hljs-number">0</span>&amp;&amp;flag[i]&amp;&amp;HT[s1].weight&gt;HT[i].weight)s1=i;<br>&#125;<br>flag[s1]=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(HT[s2].weight!=<span class="hljs-number">0</span>&amp;&amp;flag[i]&amp;&amp;HT[s2].weight&gt;HT[i].weight)s2=i;<br>&#125;<br>flag[s2]=<span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以用<strong>堆</strong>优化，但要注意不光要照顾权重还要照顾深度。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>threaded binary tree</title>
    <link href="/2021/10/31/threaded-binary-tree/"/>
    <url>/2021/10/31/threaded-binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Threaded-Binary-Tree"><a href="#Threaded-Binary-Tree" class="headerlink" title="Threaded Binary Tree"></a>Threaded Binary Tree</h1><p>线索二叉树实际上是对二叉树的一种优化，利用二叉树中的空链域(n+1个)来存储前驱或后继。</p><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>image<img src="/img/tree/3.jpg" alt="存储结构"></p><p>0代表不空，1代表空</p><p>如果左边空就将lchild链接前驱，如果右边空就将rchild链接后继。</p><h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><p>先序线索二叉树</p><p>中序线索二叉树</p><p>后续线索二叉树</p><p>如图以后续线索二叉树为例</p><p>image<img src="/img/tree/4.png" alt="后继"></p><h2 id="mend"><a href="#mend" class="headerlink" title="mend"></a>mend</h2><p>后续二叉树并不完善，无法做到全部查找后继，需要栈的辅助</p><p>原因：</p><p>​    后续线索二叉树是左右根</p><p>​    如图根节点可能没有空余的指针，所以根节点可能找不到后继，因此需要栈来记录父节点。</p><p>​    image<img src="/img/tree/4.png" alt="后继"></p><p>同理先序二叉树也不完善，无法查找全部前驱。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binary tree</title>
    <link href="/2021/10/22/binary-tree/"/>
    <url>/2021/10/22/binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Binary-tree"><a href="#Binary-tree" class="headerlink" title="Binary tree"></a>Binary tree</h1><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>​    二叉树是另一种树形结构，其特点是每个结点至多有两棵子树（即二叉树中不存在度大于二节点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>​    二叉树也是递归定义。二叉树是n(n&gt;=0)个结点的有限集合：</p><ol><li><p>或者为空二叉树，即n=0。</p></li><li><p>或者为一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树有分别是一棵二叉树。</p><p>二叉树是有序树，若其左右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分他是左子树还是右子树。二叉树的5种基本状态就看书吧。</p></li></ol><p>二叉树与度为2的有序树的区别：</p><p>​    1.度为2的树至少有3个结点，而二叉树可以为空。</p><p>​    2.度为2的有序树的孩子的左右次序是相当于另一孩子而言，若某个结点只有一个孩子，则这个孩子就无需区分其左右次序，而二叉树无论其左右孩子是否为2，均为确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而确定的。</p><h2 id="Special-binary-tree"><a href="#Special-binary-tree" class="headerlink" title="Special binary tree"></a>Special binary tree</h2><p>​    1.满二叉树：高为h，且含有$2^{h}-1$的结点的二叉树称为满二叉树，即树中每层都含有最多节点。可用序号表述，若双亲结点为$i/2$,则有左右孩子时，左孩子为$2<em>i$,右孩子为$2</em>i+1$。</p><p>​    2.完全二叉树：就是将要成为满二叉树，最后一层可能与满二叉树不同的树。</p><p>​        1）若$i&lt;\lfloor n/2 \rfloor$,他就是分支节点。</p><p>​        2）若有度为一的结点，则只有一个，且只有左孩子。</p><p>​        3）一旦出现度为1的结点，它后面全是叶子节点。</p><p>​        4）n为奇数，则每个分支都有左右孩子，若n为偶数，则序号的最大分支结点<strong>（编号为$n/2$）</strong>只有左孩子，其余没得左右孩子。</p><p>​    3.  二叉排序树：左子树上的结点均小于根节点的关键字。右子树上所有节点的关键字都大于根节点的关键字。左子树和右子树又是二叉排序树。</p><p>​    4.平衡二叉树：树上任意节点的左子树和右子树的深度只差不超过1。</p><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><ol><li>非空二叉树上的叶子结点数等于度为2的节点数加1，即n0=n2+1。</li><li>非空二叉树第k层上至多有$2^{k-1}$个结点。</li><li>高度为h的二叉树至多有$2^h-1$个结点。</li><li>具有n个结点的完全二叉树的高度为$\lfloor log_2{n}\rfloor+1$或$\lceil log_2{n}+1 \rceil$</li><li>$2^{h-1}-1&lt;n&lt;=2^{h}-1$或$2^{h-1}&lt;=n&lt;2^h$</li></ol><h2 id="storage-structure"><a href="#storage-structure" class="headerlink" title="storage structure"></a>storage structure</h2><p>1.顺序存储结构</p><p>​    有一段连续的地址存储单元，自上而下，自左而右存储完全而完全二叉树上的结点。</p><p>​    缺点： 浪费空间</p><p>​    优点：好查找</p><p>2.链式结构存储</p><p><img src="/img/tree/1.png" alt="链式结构"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>ElemType data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;*BiTree,BiTNode;<br></code></pre></td></tr></table></figure><p>优点：空间利用率高</p><p>缺点：需要的查找时间长</p><h2 id="basic-operation"><a href="#basic-operation" class="headerlink" title="basic operation"></a>basic operation</h2><h3 id="链式结构下"><a href="#链式结构下" class="headerlink" title="链式结构下"></a>链式结构下</h3><h4 id="1-创建而二叉树"><a href="#1-创建而二叉树" class="headerlink" title="1.创建而二叉树"></a>1.创建而二叉树</h4><p>创建二叉树用的是二叉树的递归定义。</p><p>按先序遍历来创建二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateBitree</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<br><span class="hljs-keyword">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<span class="hljs-comment">//递归出口</span><br>T=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<span class="hljs-comment">//分配空间</span><br>        T.data=ch;<br>       <span class="hljs-built_in">CreateBitree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBitree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-先序遍历"><a href="#2-先序遍历" class="headerlink" title="2.先序遍历"></a>2.先序遍历</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreorderTraversal</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,T-&gt;data);<span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">PreorderTraversal</span>(T-&gt;lchild);<br>    <span class="hljs-built_in">PreorderTraversal</span>(T-&gt;rchild);<br></code></pre></td></tr></table></figure><h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreorderTraversal</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<br>    stack S;<br>    BiTree p=T;<br><span class="hljs-keyword">if</span>(T)&#123;<span class="hljs-comment">//非空树就遍历</span><br><span class="hljs-built_in">InitStack</span>(S);<span class="hljs-comment">//初始化栈</span><br>        <span class="hljs-keyword">while</span>(p||!<span class="hljs-built_in">IsEmpty</span>(S))&#123;<span class="hljs-comment">//栈里不空就可以遍历</span><br>        <span class="hljs-keyword">if</span>(p)&#123;<span class="hljs-comment">//往左边走到头</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,p-&gt;data);<span class="hljs-comment">//先访问根节点</span><br>            <span class="hljs-built_in">push</span>(S,p);<span class="hljs-comment">//根入栈</span><br>           p=p-&gt;lchild;<span class="hljs-comment">//指向左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">pop</span>(S,p);<span class="hljs-comment">//空了就出栈</span><br>            p=p-&gt;rchild;<br>        &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二叉树千变万变离不开这两个操作</strong></p><h4 id="3-层序遍历（非递归）"><a href="#3-层序遍历（非递归）" class="headerlink" title="3.层序遍历（非递归）"></a>3.层序遍历（非递归）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>LQueue Q;<br>    BiTree p=T;<br>    <span class="hljs-keyword">if</span>(T)&#123;<br><span class="hljs-built_in">InitQueue</span>(Q);<br>        <span class="hljs-built_in">EnQueue</span>(Q,p);<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(Q))&#123;<span class="hljs-comment">//每次把队头的孩子放进来，不空就队首出队，O(n)。</span><br>            <span class="hljs-built_in">DeQueue</span>(Q,p);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br>            <span class="hljs-keyword">if</span>(p-&gt;lchild)<span class="hljs-built_in">EnQueue</span>(Q,p-&gt;lchild);<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild)<span class="hljs-built_in">EnQueue</span>(Q,p-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>可以很轻松的实现层序遍历，但只能存完全二叉树。</p><h4 id="1-层序遍历（输入）"><a href="#1-层序遍历（输入）" class="headerlink" title="1.层序遍历（输入）"></a>1.层序遍历（输入）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> bitree[<span class="hljs-number">100010</span>];<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;bitree[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-先序遍历-1"><a href="#2-先序遍历-1" class="headerlink" title="2.先序遍历"></a>2.先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreorderTraversal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bitree[],<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(u&gt;n)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,bitree[i]);<br>    <span class="hljs-built_in">PreorderTraversal</span>(bitree,u*<span class="hljs-number">2</span>,n);<br>    <span class="hljs-built_in">PreorderTraversal</span>(bitree,u*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,n);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要利用的是二叉树的性质。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tree</title>
    <link href="/2021/10/21/tree/"/>
    <url>/2021/10/21/tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><h3 id="1-definition"><a href="#1-definition" class="headerlink" title="1.definition"></a>1.definition</h3><p>​        树是n个（n&gt;=0）节点的有限集。当n=0时，称为空树。 在任意一棵非空树中应满足：</p><p>​        1.有且仅有一个特定的称为根的节点</p><p>​        2.当n&gt;1时, 其余节点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一颗树，并            且称为根的子树。</p><p>​        这个定义很明显是递归定义，即在树的定义中用到了自身。</p><p>​        树是一种递归的数据结构。</p><p>​        树作为一种逻辑结构具有以下两个特点：</p><p>​            1）树的根节点没有前驱，除根结点以外所有节点有且只有一个前驱。</p><p>​            2）树的所有节点可以拥有0或多个后继。</p><h3 id="2-trem"><a href="#2-trem" class="headerlink" title="2.trem"></a>2.trem</h3><p>​        树的高：数的最大层数。</p><p>​        节点的度：节点的孩子个数。（这里要区分离散数学里的度）</p><p>​        树的度：节点度最大的数</p><p>​        叶子节点：度为0的节点。</p><p>​        有序树：节点的左右子树从左到右有序。</p><p>​        无序树：节点的左右子树从左到右无序。</p><p>​        路径：两个节点的路径是这两个节点之间所经过节点序列构成的。</p><p>​        路径长度： 路径上所经过的边的个数。</p><h3 id="3-property"><a href="#3-property" class="headerlink" title="3.property"></a>3.property</h3><p>​        1）节点数=节点度数之和+1</p><p>​        2）度为m的树上，第i层至多有$m^{i-1}$个节点。</p><p>​        3）高为h的m叉树至多有（$m^{h}$-1)(m-1)。</p><p>​        4）n个节点的m叉树的最小高度为$\log_m^{n(m-1)+1}$</p><h3 id="4-fores"><a href="#4-fores" class="headerlink" title="4.fores"></a>4.fores</h3><p>​        m棵互不相交树的集合。（他可以和书相互转换）</p><h4 id="5-树和森林的遍历"><a href="#5-树和森林的遍历" class="headerlink" title="5.树和森林的遍历"></a>5.树和森林的遍历</h4><h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>先根遍历和后根遍历</p><p>先根遍历是树对应二叉树的先序遍历</p><p>后根遍历是树对应二叉树的中序遍历</p><h5 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h5><p>森林是和二叉树一样</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2021/09/29/KMP/"/>
    <url>/2021/09/29/KMP/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>1.朴素算法</p><p>2.KMP算法的过程</p><p>3.next数组求法</p><p>4.KMP算法代码实现</p><p>5.next数组优化</p><h2 id="1-朴素算法"><a href="#1-朴素算法" class="headerlink" title="1.朴素算法"></a>1.朴素算法</h2><p>  字符串匹配的朴素算法是文本串T与匹配串P逐个比较的过程。</p><p><img src="/img/KMP/1.png" alt="朴素算法图"></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string T,string P)</span></span>&#123;<br><span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;T.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//遍历T中元素 </span><br><span class="hljs-keyword">if</span>(T[i]==P[j])i++,j++;<span class="hljs-comment">//对T[i]与P[j]对比，相等就比较下一位。 </span><br><span class="hljs-keyword">else</span> &#123; <br>i=i-j+<span class="hljs-number">1</span>;<span class="hljs-comment">//不等就i指针到刚开始的下一位，j从头开始 </span><br>j=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(j==P.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//模式串匹配完，输出文本串的开始匹配的位置.</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i-j);<br>&#125;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-KMP算法的过程"><a href="#2-KMP算法的过程" class="headerlink" title="2.KMP算法的过程"></a>2.KMP算法的过程</h2><p>​    KMP算法就比较机智的利用模式串中本身蕴含的信息跳过了一些不必要被比较。</p><p>如下图，匹配失败，j回到图示绿色位置而i不变化，这样可以减少下一次比较次数且不会有丢落，原因就是P1,P2和S1串相同，我们利用已知的信息可以跳过从头开始比较相同子串的过程，并且这样相同的子串越长可节约的时间就越多。</p><p><img src="/img/KMP2.png" alt="KMP过程图"></p><h2 id="3-next数组求法"><a href="#3-next数组求法" class="headerlink" title="3.next数组求法"></a>3.next数组求法</h2><p><a href="https://www.bilibili.com/video/BV1hW411a7ys?spm_id_from=333.999.0.0">KMP字符串匹配算法2_哔哩哔哩_bilibili</a></p><p>下面的解释看到6：20就行。</p><p>​    于是我们需要初始化求得一个信息表（next数组），来记录每一个字符前子串中的前缀与后缀相同的最大长度（前缀是不含子串最后一个字符的，同理后缀），并且这种性质一定藏在模式串P中，所以我们无需考虑文本串T,只对P操作就可以。</p><p>​    比如：P: $abaabcac$</p><p>​    0: a—没有相同   —下一个为a才行</p><p>​    1: ab—最大前缀是a，最大后缀是b，没相同  —下一个为a才行</p><p>​    2: aba—前缀是a，后缀是a最大，为1    —下一个字符要想加入最大前后缀必须为b</p><p>​    3: abaa—不是b,但和首字符相同，为1    —下一个字符要想加入最大前后缀必须为b</p><p>​    4:abaab—是b 为2    —下一个字符要想加入最大前后缀必须为a</p><p>​    5:abaabc—不是a, 回到0:也不行，为0  —下一个为a才行</p><p>​    6:abaabca—是a, 为1    —下一个为b才行对应2的条件</p><p>​    可以看出这是一个递归的求解，下一个与前一个有关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(string P,<span class="hljs-keyword">int</span> next[])</span></span>&#123;<br>i=<span class="hljs-number">1</span>;next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;P[<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||P[i]==P[j])&#123;i++;j++;next[i]=j;&#125;<br>        <span class="hljs-keyword">else</span> j=next[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/KMP/3.png" alt="next"></p><pre><code>## 4.KMP算法代码实现</code></pre><p>KMP算法算法实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> T[],<span class="hljs-keyword">char</span> P[])</span></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span>  ne[<span class="hljs-number">100010</span>];<br>n=<span class="hljs-built_in">strlen</span>(T);<br>m=<span class="hljs-built_in">strlen</span>(P);<br><span class="hljs-built_in">get_next</span>(P,ne);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,p=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">while</span>(p&gt;<span class="hljs-number">0</span>&amp;&amp;T[i]!=P[p])<span class="hljs-comment">//递归可以节约的点</span><br>p=ne[p<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(T[i]==P[p])p++;<span class="hljs-comment">//匹配上就比较下一个</span><br><span class="hljs-keyword">if</span>(p==m)cout&lt;&lt;i-p+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-next数组优化"><a href="#5-next数组优化" class="headerlink" title="5.next数组优化"></a>5.next数组优化</h2><p>可以看出当T与P匹配不上时就去查找对应信息表，一直只查到可以匹配上或者开头。于是在get_next时就可以直接递归到位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(<span class="hljs-keyword">char</span> p[],<span class="hljs-keyword">int</span>* ne)</span></span>&#123;<br><span class="hljs-keyword">int</span> m;<br>m=<span class="hljs-built_in">strlen</span>(p);<br>ne[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>&amp;&amp;p[i]!=p[k])<br>k=p[k<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(p[i]==p[k])&#123;<br>k++;<br>&#125;<br>ne[i]=k;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AcWing版代码"><a href="#AcWing版代码" class="headerlink" title="AcWing版代码"></a>AcWing版代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000010</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> ne[N];<br><span class="hljs-keyword">char</span> T[N],P[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make_next</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br><span class="hljs-keyword">while</span>(j&amp;&amp;P[i]!=P[j])j=ne[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(P[i]==P[j])j++;<br>        ne[i]=j;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">make_next</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">while</span>(j&amp;&amp;T[i]!=P[j])j=ne[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(T[i]==P[j])j++;<br>        <span class="hljs-keyword">if</span>(j==m)cout&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;m&gt;&gt;P&gt;&gt;n&gt;&gt;T;<br>    <span class="hljs-built_in">kmp</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C string to float number</title>
    <link href="/2021/09/14/C-string-to-float-number/"/>
    <url>/2021/09/14/C-string-to-float-number/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>c=getchar();<br><span class="hljs-keyword">double</span> data=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> tans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<span class="hljs-comment">//#输入结束</span><br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>flag=<span class="hljs-literal">false</span>;<br>c=getchar();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(flag)data=data*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">else</span> &#123;<br>tans*=<span class="hljs-number">0.1</span>;<br>data+=tans*(c-<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;<br>c=getchar();<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My first blog</title>
    <link href="/2021/09/12/my-first-blog/"/>
    <url>/2021/09/12/my-first-blog/</url>
    
    <content type="html"><![CDATA[<p>​    I cross a vary hard way to get a blog which to record my experience.</p>]]></content>
    
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
